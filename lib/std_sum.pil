function init_challenges(int extra) {
    once {
        global challenge std_alpha stage(2);
        global challenge std_beta stage(2);
        global challenge std_gamma stage(3);
    }
    if (extra) {
        once global challenge std_delta stage(3);
    }
}

function init_coset_constants(int len) {
    global std_ks[len];

    for (int i = 0; i < len; ++i) {
        std_ks[i] = global constant k[i];
    }
}

/**
 * Given two multisets A and B, check whether A is equal to B.
 * @param selF selector to decide which elements of colsF are included in multiset A
 * @param colsF columns to be included in multiset A
 * @param selT selector to decide which elements of colsT are included in multiset B
 * @param colsT columns to be included in multiset B
 * @return Constraints to be satisfied by A and B to ensure the multiset check
 */
function multiset_check(expr selF, expr colsF[], expr selT, expr colsT[]) {
    init_challenges(0);
    if (length(colsF) != length(colsT)) {
        error(`colsF and colsT must be same dimensions`);
    }

    selF * (1 - selF) === 0;
    selT * (1 - selT) === 0;

    col fixed L1 = [1,0...];

    expr colsF_compressed = 0;
    expr colsT_compressed = 0;
    for (int icol = length(colsF) - 1; icol > 0; --icol) {
        colsF_compressed = (colsF_compressed + colsF[icol]) * std_alpha;
        colsT_compressed = (colsT_compressed + colsT[icol]) * std_alpha;
    }
    colsF_compressed = (colsF_compressed + colsF[0]);
    colsT_compressed = (colsT_compressed + colsT[0]);

    expr colsF_selected = selF * (colsF_compressed - std_beta) + std_beta;
    expr colsT_selected = selT * (colsT_compressed - std_beta) + std_beta;

    col witness gsum stage(3);

    //                                   1                              1
    //  gsum' === gsum +  ---------------------------- - ----------------------------
    //                    (colsT_selected + std_gamma)   (colsF_selected + std_gamma)

    L1 * gsum === 0;
    (gsum' - gsum) * (colsT_selected + std_gamma) * (colsF_selected + std_gamma) === (colsF_selected + std_gamma) - (colsT_selected + std_gamma);
}

/**
 * Given two multisets A and B, check whether A is a subset of B (viewed as sets).
 * @param selF selector to decide which elements of colsF are included in multiset A
 * @param colsF columns to be included in multiset A
 * @param selT selector to decide which elements of colsT are included in multiset B
 * @param colsT columns to be included in multiset B
 * @return Constraints to be satisfied by A and B to ensure the lookup check
 */
function lookup_check(col selF, expr colsF[], col selT, expr colsT[]) {
    init_challenges(1);
    if (length(colsF) != length(colsT)) {
        error(`colsF and colsT must be same dimensions`);
    }

    selF * (1 - selF) === 0;
    selT * (1 - selT) === 0;

    col fixed L1 = [1,0...];

    expr colsF_compressed = 0;
    expr colsT_compressed = 0;
    for (int icol = length(colsF) - 1; icol > 0; --icol) {
        colsF_compressed = (colsF_compressed + colsF[icol]) * std_alpha;
        colsT_compressed = (colsT_compressed + colsT[icol]) * std_alpha;
    }
    colsF_compressed = (colsF_compressed + colsF[0]);
    colsT_compressed = (colsT_compressed + colsT[0]);

    expr colsT_selected = selT * (colsT_compressed - std_beta) + std_beta;
    expr colsF_selected = selF * (colsF_compressed - colsT_selected) + colsT_selected;

    // Define the (normalized) multiplicity polynomial m:
    //       |j ∈ [N]: colsF_selected_j = colsT_selected_i|
    // m_i = ----------------------------------------------
    //       |j ∈ [N]: colsT_selected_j = colsT_selected_i|
    @lookup_check {m: m, colsT: colsT_selected, colsF: colsF_selected, gsum: gsum };
    col witness m stage(2);

    col witness gsum stage(3);

    //                                   m                              1
    //  gsum' === gsum +  ---------------------------- - ----------------------------
    //                    (colsT_selected + std_gamma)   (colsF_selected + std_gamma)

    L1 * gsum === 0;
    (gsum' - gsum) * (colsT_selected + std_gamma) * (colsF_selected + std_gamma) === m * (colsF_selected + std_gamma) - (colsT_selected + std_gamma);
}

/**
 * Given multisets A1,...,An and B1,...,Bn, check whether A1,...,An does not vary 
 * after applying the permutation B1,...,Bn to itself.
 * @param cols columns subject to the permutation
 * @param Sperms columns defining the permutation
 * @return Constraints to be satisfied by A and B to ensure the connection check
 */
function connection_check(expr cols[], expr Sperms[]) {
    constant len = length(cols);

    init_challenges(1);
    init_coset_constants(len);

    if (len != length(Sperms)) {
        error(`cols and Sperms must be same dimensions`);
    }

    col fixed L1 = [1,0...];
    col fixed IDEN = [1,omega,..*..,omega**(N-1)];

    col witness gsum stage(3);

    // Define SIDs[i] = k_i·X polynomials
    expr SIDs[len];
    for (int icol = 0; icol < len; ++icol) {
        SIDs[icol] = std_ks[icol] * IDEN;
    }

    //                                               1                                                               1
    //  gsum' === gsum +  ----------------------------------------------------------- - -----------------------------------------------------------
    //                    (f_0 + gamma·X + delta) · ... · (f_N + gamma·k_2·X + delta)   (f_0 + gamma·S_0 + delta) · ... · (f_N + gamma·S_n + delta)                 

    expr first_summand = 1;
    expr second_summand = 1;
    for (int icol = 0; icol < len; ++icol) {
        first_summand = first_summand * (cols[icol] + std_gamma*SIDs[icol] + std_delta);
        second_summand = second_summand * (cols[icol] + std_gamma*Sperms[icol] + std_delta);
    }

     L1 * gsum === 0;
    (gsum' - gsum) * first_summand * second_summand ===  second_summand - first_summand;
}