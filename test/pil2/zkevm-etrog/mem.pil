include "global.pil";

subproof Mem(2**23) {

    const expr INCS = Global.STEP + 1;
    const expr ISNOTLAST = (1 - Global.LLAST);
    const int MAX_STEP = 2**23;

    // single: 13 cols
    // double: 15 cols <== safe area if more than 26.7% of memory access are R-R,W-R for same addr and value
    // for example: with 80% => double = 60% * single (safe 40% of area)

    col witness addr;
    col witness step[2];
    col witness mOp, mWr;
    col witness value[8];
    col witness isDouble;
    col witness lastAccess; // 1 if its the last access of a given address

    // The list is sorted by [addr, step]
    lastAccess * (1 - lastAccess) = 0;
    isDouble * (1 - isDouble) = 0;
    isDouble * (1 - mOp) = 0;

    const expr stepDelta = step[0]' + isDouble * (step[0] - step[1]) - step[0];

    range_check(ISNOTLAST, lastAccess * (addr' - addr - stepDelta) + stepDelta, 1, MAX_STEP);
    range_check(isDouble, step[1] - step[0], 1, MAX_STEP);


    // ISNOTLAST { lastAccess * (addr' - addr - (step'-step)) + (step'-step) } in INCS;
    (1 - lastAccess) * (addr' - addr) = 0;

    mOp * (1 - mOp) === 0;
    mWr * (1 - mWr) === 0;
    // mWr could be 1 only if mOp is 1
    (1 - mOp) * mWr = 0;

    const expr isWrite = mOp' * mWr';
    const expr rdSame = (1-isWrite) * (1-lastAccess);
    const expr rdDifferent = (1-isWrite) * lastAccess;

    // lastAccess has to be 1 in the last evaluation. This is necessary to
    // validate [rdDifferent * (val[0]') = 0;] correctly (in a cyclic way)
    (lastAccess - 1) * (1 - ISNOTLAST) = 0;

    for (int index = 0; index < length(val); index += 1) {
        rdSame * (value[index]' - value[index])  =  0;
        rdDifferent * (value[index]')  =  0;
    }

    multiset_proves(MEM_ID, mOp, [addr, step[0], mWr, ...value]);

    // only allowed double operations: R R or W R (always same addr and value)
    // second operation always is a read
    multiset_proves(MEM_ID, isDouble, [addr, step[1], 0, ...value]);
}