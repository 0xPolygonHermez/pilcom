include "poseidong.pil";
include "climb_key.pil";

const int STORAGE_ID 10;

subproof Storage(2**23) {

    col witness free0, free1, free2, free3;

    // Registers
    col witness hashLeft[4];
    col witness hashRight[4];
    col witness oldRoot[4];
    col witness newRoot[4];
    col witness valueLow[4];
    col witness valueHigh[4];
    col witness siblingValueHash[4];
    col witness rkey[4];
    col witness siblingRkey[4];
    col witness rkeyBit;
    col witness level;
    col witness pc;

    col witness inOldRoot;
    col witness inNewRoot;
    col witness inValueLow;
    col witness inValueHigh;
    col witness inSiblingValueHash;
    col witness inRkey;
    col witness inRkeyBit;
    col witness inSiblingRkey;
    col witness inFree;
    col witness inRotlVh;
    col witness inLevel;

    col witness setHashLeft;
    col witness setHashRight;
    col witness setOldRoot;
    col witness setNewRoot;
    col witness setValueLow;
    col witness setValueHigh;
    col witness setSiblingValueHash;
    col witness setRkey;
    col witness setSiblingRkey;
    col witness setRkeyBit;
    col witness setLevel;

    col witness hash;
    col witness hashType;
    col witness latchSet;
    col witness latchGet;
    col witness climbRkey;
    col witness climbSiblingRkey;
    col witness climbBitN;
    col witness jmpz;
    col witness jmpnz;
    col witness jmp;
    col witness const0;
    col witness jmpAddress;

    col witness incCounter;
    incCounter' === incCounter * (1 - latchSet - latchGet - Global.L1) + hash;

    // We assume hash and latch never goes together
    // We assume first instruction is not a latch nor a hash.

    // Selectors

    const expr op[4];
    const expr climbKey[4];
    for (int index = 0; index < 4; ++index) {
        op[index] = (index == 0 ? 0 : (inLevel * level + inRkeyBit * rkeyBit + const0)) +
            inOldRoot * oldRoot[index] +
            inNewRoot * newRoot[index] +
            inValueLow * valueLow[index] +
            inValueHigh * valueHigh[index] +
            inSiblingValueHash * siblingValueHash[index] +
            inSiblingRkey * siblingRkey[index] +
            inRkey * rkey[index] +
            inFree * free[index] +
            inRotlVh * valueHigh[(index + 3) % 4];

        climbKey[index] = climbRkey * rkey[index] + climbSiblingRkey * siblingRkey[index];
        // Setters

        hashLeft[index]' === setHashLeft * (op[index] - hashLeft[index]) + hashLeft[index];
        hashRight[index]' === setHashRight * (op[index] - hashRight[index]) + hashRight[index];
        oldRoot[index]' === setOldRoot * (op[index] - oldRoot[index]) + oldRoot[index];
        newRoot[index]' === setNewRoot * (op[index] - newRoot[index]) + newRoot[index];
        valueLow[index]' === setValueLow * (op[index] - valueLow[index]) + valueLow[index];
        valueHigh[index]' === setValueHigh * (op[index] - valueHigh[index]) + valueHigh[index];
        siblingValueHash[index]' === setSiblingValueHash * (op[index] - siblingValueHash[index]) + siblingValueHash[index];
        rkey[index]' === setRkey * (op[index] - rkey[index]) + rkey[index];
        siblingRkey[index]' === setSiblingRkey * (op[index] - siblingRkey[index]) + siblingRkey[index];
    }

    rkeyBit' === setRkeyBit * (op0-rkeyBit) + rkeyBit;
    rkeyBit * (1 - rkeyBit) === 0;

    level' === setLevel * (op0-level) + level;

    // Instruction that guarantees that op = hash(hl, hr); the poseidon SM will do the work; the result will be feeded by free

    multiset_assumes(POSEIDON_G_ID, hash, [ ...hashLeft, ...hashRight3, hashType, 0, 0, 0, ...op0]);
/*
    } is PoseidonG.result3 {
            PoseidonG.in0,
            PoseidonG.in1,
            PoseidonG.in2,
            PoseidonG.in3,
            PoseidonG.in4,
            PoseidonG.in5,
            PoseidonG.in6,
            PoseidonG.in7,
            PoseidonG.hashType,
            PoseidonG.cap1,
            PoseidonG.cap2,
            PoseidonG.cap3,
            PoseidonG.hash0,
            PoseidonG.hash1,
            PoseidonG.hash2,
            PoseidonG.hash3};
*/
    const expr climbKeyBit = climbBitN * (1 - rkeyBit) + (1 - climbBitN) * rkeyBit;

    multiset_assumes(CLIMB_KEY_ID, climbRkey + climbSiblingRkey, [...climbKey, level, climbKeyBit, ...op0])
    /*
    climbRkey + climbSiblingRkey {
        climbRkey * rkey0 + climbSiblingRkey * siblingRkey0, climbRkey * rkey1 + climbSiblingRkey * siblingRkey1, climbRkey * rkey2 + climbSiblingRkey * siblingRkey2, climbRkey * rkey3 + climbSiblingRkey * siblingRkey3,
        level, climbKeyBit,
        op0, op1, op2, op3
    } is ClimbKey.result {
        ClimbKey.key0, ClimbKey.key1, ClimbKey.key2, ClimbKey.key3,
        ClimbKey.level', ClimbKey.bit,
        ClimbKey.key0', ClimbKey.key1', ClimbKey.key2', ClimbKey.key3'
    };*/

    
    col witness op0inv;

    const expr opIsZero === 1 - op0 * op0inv;
    opIsZero * op0 === 0;

    const expr doJump === jmp + jmpz * opIsZero + jmpnz * (1 - opIsZero);
    pc' === doJump * (jmpAddress - pc - 1) + pc + 1;

    pc * Global.L1 === 0;
    incCounter * Global.L1 === 0;

    // Last pc' must return to be pc = 0 in order to close the program loop
    // Once the work is done, the rest of instructions must be:
    // if op0 = $n-1 (last instruction of the program) then pc = 0 (jump to the beginning of the program)

    /*
       code generated with:
       node tools/pil_pol_table/bits_compose.js "hash,hashType,latchGet,latchSet,climbRkey,climbSiblingRkey,climbBitN,jmpz,jmp,setHashLeft,setHashRight,setLevel,setNewRoot,setOldRoot,setRkey,setRkeyBit,setSiblingRkey,setSiblingValueHash,setValueHigh,setValueLow,jmpnz,inFree,inNewRoot,inOldRoot,inRkey,inRkeyBit,inSiblingValueHash,inValueLow,inValueHigh,inRotlVh,inLevel" -b
    */

    const expr operation =
          2**0  * hash                  + 2**1  * hashType              + 2**2  * latchGet              + 2**3  * latchSet
        + 2**4  * climbRkey             + 2**5  * climbSiblingRkey      + 2**6  * climbBitN             + 2**7  * jmpz
        + 2**8  * jmp                   + 2**9  * setHashLeft           + 2**10 * setHashRight          + 2**11 * setLevel
        + 2**12 * setNewRoot            + 2**13 * setOldRoot            + 2**14 * setRkey               + 2**15 * setRkeyBit
        + 2**16 * setSiblingRkey        + 2**17 * setSiblingValueHash   + 2**18 * setValueHigh          + 2**19 * setValueLow
        + 2**20 * jmpnz                 + 2**21 * inFree                + 2**22 * inNewRoot             + 2**23 * inOldRoot
        + 2**24 * inRkey                + 2**25 * inRkeyBit             + 2**26 * inSiblingValueHash    + 2**27 * inValueLow
        + 2**28 * inValueHigh           + 2**29 * inRotlVh              + 2**30 * inLevel;

        (1 - hash) * hash === 0;
        (1 - hashType) * hashType === 0;
        (1 - latchGet) * latchGet === 0;
        (1 - latchSet) * latchSet === 0;
        (1 - climbRkey) * climbRkey === 0;
        (1 - climbSiblingRkey) * climbSiblingRkey === 0;
        (1 - climbBitN) * climbBitN === 0;
        (1 - jmpz) * jmpz === 0;
        (1 - jmp) * jmp === 0;
        (1 - setHashLeft) * setHashLeft === 0;
        (1 - setHashRight) * setHashRight === 0;
        (1 - setLevel) * setLevel === 0;
        (1 - setNewRoot) * setNewRoot === 0;
        (1 - setOldRoot) * setOldRoot === 0;
        (1 - setRkey) * setRkey === 0;
        (1 - setRkeyBit) * setRkeyBit === 0;
        (1 - setSiblingRkey) * setSiblingRkey === 0;
        (1 - setSiblingValueHash) * setSiblingValueHash === 0;
        (1 - setValueHigh) * setValueHigh === 0;
        (1 - setValueLow) * setValueLow === 0;
        (1 - jmpnz) * jmpnz === 0;
        (1 - inFree) * inFree === 0;
        (1 - inNewRoot) * inNewRoot === 0;
        (1 - inOldRoot) * inOldRoot === 0;
        (1 - inRkey) * inRkey === 0;
        (1 - inRkeyBit) * inRkeyBit === 0;
        (1 - inSiblingValueHash) * inSiblingValueHash === 0;
        (1 - inValueLow) * inValueLow === 0;
        (1 - inValueHigh) * inValueHigh === 0;
        (1 - inRotlVh) * inRotlVh === 0;
        (1 - inLevel) * inLevel === 0;

    lookup_assumes(STORAGE_ROM_ID, 1, [operation, const0, jmpAddress, pc, inSiblingRkey]);
}