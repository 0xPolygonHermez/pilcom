const int CLIMB_KEY_ID = 10;

// ClimbKey
//
// Description:
// ============
// SM to correctly navigate (climb up) the given merkle tree path. Here, by correct, we mean verifying that not overflow occurs.
// The overflowing is detected by not including ALL possible combinations of values that produce an overflow in the lookup.
//
// usage:
//      multiset_assumes(CLIMB_KEY_ID, selector, [keyIn[0], keyIn[1], keyIn[2], keyIn[3], level, bit, keyOut[0], keyOut[1], keyOut[2], keyOut[3]]);

subproof ClimbKey(2**16, 2**20) {

    // keyIn goldilock with 4 input keys, one by clock (CLK[i]: keyIn = keyIn[i])
    col witness keyIn;

    // keyOut four output keys, one by clock (CLK[i]: keyIn = keyOut[i])
    col witness keyOut;

    // msb_level a value of 6 bits to indicate the most significant level bits of the tree (depth), level = 0 → top of tree (root)
    col witness msb_level;

    // keyIn/Out selector keySel when keySel == 0 → keyIn is the active key for current level
    col witness keySel;

    // keyInChunk = Value of the current chunk (maximum 18 bits) used to verify by the lookup and in the rebuild of the key.
    // Size of keyInChunk is 18 bits on CLK0, 17 bits on CLK1 and CLK2 and 12 bits for CLK3.
    // keyInClunk = CLK0 * keyIn[0..17] + CLK1 * keyIn[18..34] + CLK2 * keyIn[35..51] + CLK3 * keyIn[52..63]
    col witness keyInChunk;

    // Result is used to relate the storage SM with this SM via permutation
    col witness result;

    // On CLK0, carryLt == bit, for the rest of clocks used to link "state" between chunks
    // carryLt = carry + 2 * lt
    // clin = carryLtIn, clout = carryLtOut 
    // 
    //           CLK0             CLK1             CLK2             CLK3
    //        ┌─────────┐      ┌─────────┐      ┌─────────┐      ┌─────────┐  
    //   bit─>│clin     │   ┌─>│clin     │   ┌─>│clin     │   ┌─>│clin     │  
    //        │         │   │  │         │   │  │         │   │  │         │  
    //        │    clout│───┘  │    clout│───┘  │    clout│───┘  │    clout│  
    //        └─────────┘      └─────────┘      └─────────┘      └─────────┘  
    //   
    // bit is carryLt on CLK0, it's bit to add to climb up the path

    col witness carryLt;

    // clocks: CLK0, CLK1, CLK2, CLK3
    col fixed CLK3 = [0,0,0,1]...;
    const expr CLK0 = 3'CLK2;
    const expr CLK1 = 2'CLK2;
    const expr CLK2 =  'CLK2;

    // 
    // Examples
    //
    // │ CLK  │ keyIn  │ keyOut                  │ keySel │ keyInChunk     │ carryLt | h_level | result | CLK2 relative │
    // ├──────┼────────┼─────────────────────────┼────────┼────────────────┼─────────┼─────────┼────────┼───────────────┤
    // │ CLK0 │ keyIn0 │ keyOut0 (=KeyIn0)       │   0    │ keyIn1[0..17]  │   bit   │    0    │   0    │     3'x       │
    // │ CLK1 │ keyIn1 │ keyOut1 (=KeyIn1*2+bit) │   1    │ keyIn1[18..34] │    x    │    0    │   0    │     2'x       │
    // │ CLK2 │ keyIn2 │ keyOut2 (=KeyIn2)       │   0    │ keyIn1[35..51] │    x    │    0    │   0    │      'x       │
    // │ CLK3 │ keyIn3 │ keyOut3 (=KeyIn3)       │   0    │ keyIn1[52..63] │    x    │ h_level │   1    │       x       │
    //
    // │ CLK  │ keyIn  │ keyOut                  │ keySel │ keyInChunk     │ carryLt | h_level | result | CLK2 relative │
    // ├──────┼────────┼─────────────────────────┼────────┼────────────────┼─────────┼─────────┼────────┼───────────────┤
    // │ CLK0 │ keyIn0 │ keyOut0 (=KeyIn0)       │   0    │ keyIn3[0..17]  │   bit   │    0    │   0    │     3'x       │
    // │ CLK1 │ keyIn1 │ keyOut1 (=KeyIn1)       │   0    │ keyIn3[18..34] │    x    │    0    │   0    │     2'x       │
    // │ CLK2 │ keyIn2 │ keyOut2 (=KeyIn2)       │   0    │ keyIn3[35..51] │    x    │    0    │   0    │      'x       │
    // │ CLK3 │ keyIn3 │ keyOut3 (=KeyIn3*2+bit) │   1    │ keyIn3[52..63] │    x    │ h_level │   1    │       x       │

    
    // binary constraints
    keySel * (1 - keySel) === 0;
    result * (1 - result) === 0;

    // bit for each clock, on CLK0 take carryLt value, on CLK1 get the previous value of carryLt,...
    const expr bit = CLK0 * carryLt + CLK1 * 'carryLt + CLK2 * 2'carry + CLK3 * 3'carry; 

    // if keySel == 0 → keyOut === keyIn
    // if keySel == 1 → keyOut === keyIn * 2 + bit (climb-up operation)
    keyOut === keyIn + keySel * (keyIn + bit);

    const expr keySel[4] = [3'keySel, 2'keySel, 'keySel, keySel];
    const expr keyIn[4] =  [3'keyIn,  2'keyIn,  'keyIn,  keyIn];
    const expr keyOut[4] = [3'keyOut, 2'keyOut, 'keyOut, keyOut];
  
    // 1] KeyIn rebuild using chunks, keyInBuildByChunk only is used on CLK3
    const expr keyInBuildByChunk = 3'keyInChunk + 2'keyInChunk * 2**18 + 'keyInChunk * 2**35 + keyInChunk * 2**52;

    // 2] KeyIn selected with keySel
    const expr keyInSelected = keySel0 * keyIn0 + keySel1 * keyIn1 + keySel2 * keyIn2 + keySel3 * keyIn3;

    // on CLK3 check that keyIn rebuild and keyInSelect are the same → means chunks are correctly calculated. The
    // range check of these chunks values is verified throw CLIMB_KEY_TABLE.
    CLK3 * (keyInBuildByChunk - keyInSelected) === 0;

    // If there is something to calculate result is equal to 1 at CLK3. In restant situations result is zero.
    result * (1 - CLK3) = 0;

    // CLK is a sequence to identify the current clock 0,1,2,3,0,1,2,3.
    const expr CLK = CLK1 + 2 * CLK2 + 3 * CLK3;

    // CLK0 (2 bits) + keyChunk = keyIn[ 0..17] 18 bits + carry (1 bits) = 19 bits (level = 0)
    // CLK1 (2 bits) + keyChunk = keyIn[18..34] 17 bits + carryLt (2 bits) = 19 bits (level = 0)
    // CLK2 (2 bits) + keyChunk = keyIn[35..51] 17 bits + carryLt (2 bits) = 19 bits (level = 0)
    // CLK3 (2 bits) + keyChunk = keyIn[52..63] 12 bits + carryLt (2 bits) + level (6 bits)  = 20 bits (*)
    // (*) more than 50% of 2**12 are invalids for these reason they aren't included in table
    //     total size is 4 * 2 ** 19 = 2 ** 21

    lookup_assumes(CLIMB_KEY_TABLE_ID, 1, [CLK, level * CLK3, keyInChunk, carryLt, (1 - CLK3) * carryLt']);

    const expr lsb_level = keySel[3] * 3 + keySel[2] * 2 + keySel[1] * 3;
    multiset_proves(CLIMB_KEY_ID, result,  [...keyIn, ...keySel, msb_level * 4 + lsb_level, bit, ...keyOut]);
}