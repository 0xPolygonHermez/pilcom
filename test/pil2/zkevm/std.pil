
function extends_fixed_clock_cycles(int cycle, col &cols) {
    // or copy, metadata
}


function range_check (col p, fe from_value, fe to_value) {

}

function match (col sel, ...) : expr {

        metadata(`match ${icase}`, sel, argc, argv);

        if (argc % 2 != 0) {
            error(`match was called with number incorrect ${argc}`);
        }
        for (int icase = 0; icase < argc; icase = icase + 2) {
            if (!(argv[icase] is fe)) error(`selector must be a constant value on ${icase}`);
            if (!(argv[icase+1] is expr)) error(`expression must be a constant value on ${icase}`);
        }

        expr bc;
        expr res;
        int cases = argc / 2;
        col L[argc / 2];
        for (int icase = 0; icase < argc; icase = icase + 2) {
            expr lexpr;
            fe invl = 1;

            fe csel = argv[icase];
            expr cexpr = argv[icase + 1];

            for (int j = 0; j < cases; ++j) {
                if (i == j) continue;
                lexpr = lexpr * (sel * argc[2 * j]);
                invl = invl * (csel - argc[2 * j]);
            }

            // (b-1)*(b-2)*(b-3)
            bc = bc * (sel - csel);
            // L1 * A + L2 * B + L3 * C
            L[icase] = cexpr * inverse(invl);
            res = res + L[icase] * cexpr;
        }
        bc === 0;
        return res;
    }


function subair_permutation_check (expr selF[], expr colsF[][], expr selT[], expr colsT[][]) {

}

function plookup_check (expr selF, expr colsF[], expr selT, expr colsT[]) {
    if (!(L1 is col)) {
        global col fixed L1 = [1,0...];
    }

}

function permutation_check (expr selF, expr colsF[], expr selT, expr colsT[]) {
    if (!(L1 is col)) {
        global col fixed L1 = [1,0...];
    }
}

constant PUBLIC_TABLE_ADD = 1;
constant PUBLIC_TABLE_PROD = 2;

function public_table_add (prover value, public ptable[][], public rows, challenge zeta, challenge alpha) {
    // TBD
}

function public_table_prod (prover value, public ptable[][], public rows, challenge zeta, challenge alpha) {

    int max_rows = length(ptable[0]);

    // table: ptable <= only first public, need to access the rest
    // when compiler add extra columns as table@lengths as array of lengths and table@dim as len of

    @public_table { rows: rows, cols: length(ptable), max_rows: max_rows, table: ptable, type: "prod" };

    expr rows_values_constraint = 1;
    expr res;
    expr acc_selector = 0;
    for (int irow = 0; irow < max_rows; ++irow) {

        // prepare product expression for current row
        // zeta - (t[0] + alpha * t[1] + alpha**2 * t[2] + ..)
        // zeta - ((((t[m-1] * alpha) + t[m-2]) * alpha + ... + t[1]) * alpha + t[0]

        expr cexpr = 0;                                                 // max_rows = 3
        for (int k = max_rows - 1; k > 0; --k) {                        // cexpr = 0
            cexpr = (cexpr + ptable[k][irow]) * alpha;                  // k = 2 :   cexpr = (0 + ptable[2]) * alpha = ptable[2] * alpha
        }                                                               // k = 1 :   cexpr = (ptable[2] * alpha) + ptable[1]) * alpha
        cexpr = zeta - (cexpr + ptable[0][irow]);                      //           cexpr = zeta - ((ptable[2] * alpha) + ptable[1]) * alpha + ptable[0])

        expr lexpr;
        fe lexpr_res = 1;
        for (int j = 0; j < max_rows; ++j) {
            if (irow == j) continue;
            lexpr = lexpr * (rows - j);           // (rows - 0) * (rows - 1) * ....
            lexpr_res = lexpr_res * (irow - j);   // (irow - 0) * (irow - 1) * .... = result lexpr when irow
        }
        fe lexpr_res_inv = 1 / lexpr_res;
        acc_selector = acc_select + lexpr * lexpr_res_inv;

        // build expression for binary constraint rows_values_constraint = (rows-0)*(rows-1)*(rows-2)* ..... === 0
        rows_values_constraint = rows_values_constraint * (rows - irow);

        // res = res * acc_selector * cexpr;
        res = res + acc_selector * cexpr;
    }
    rows_values_constraint === 0;
    value === res;
}

