

subproof PaddingKK:: {

    include "padding_kkbit.pil"
    include "keccakf.pil"

    col fixed OFFSET = [0..31]...;
    // col fixed BYTE_FACTOR;

    col fixed R8_ID;
    col fixed LAST_BLOCK;
    col fixed LAST_BLOCK_LATCH;
    col fixed R8_VALID;
    col fixed S_OUT_ID;
    col fixed FORCE_LAST_HASH;

    // Polynomials that are used to compute a hash chunk
    col witness freeIn;
    col witness connected;
    col witness addr;

    // rem: It can be different only the first byte of a new Hash.
    col witness rem;

    rem' * (1-lastHash) === (rem-1)*(1-lastHash);

    col witness remInv;
    col remIsZero = 1 - rem*remInv;
    remIsZero*rem === 0;

    col witness spare;
    col lastHash = LAST_BLOCK * (spare + remIsZero);
    col lastHashLatch = LAST_BLOCK_LATCH * (spare + remIsZero);
    spare' === (spare + remIsZero) * (1 - lastHash);
    spare * (1 - spare) === 0;

    col witness lastHashLen;
    col witness lastHashDigest;

    lastHashLen * (1 - lastHashLen) === 0;
    lastHashDigest * (1 - lastHashDigest) === 0;

    lastHashLen * (1 - lastHashLatch) === 0;
    lastHashDigest * (1 - lastHashLatch) === 0;

    col aFreeIn = (1 - (remIsZero + spare))*freeIn + remIsZero + lastHash * 0x80;

    lookup_check(R8_VALID,
                 [aFreeIn, R8_ID, connected],
                 [PaddingKKBit.r8, PaddingKKBit.r8Id, PaddingKKBit.connected]);

    when (1 - LAST_BLOCK) { connected' === connected };
    when (LAST_BLOCK)     { connected' === (1 - lastHash) };

    lookup_check ( lastHashLatch,
                   [...hash, S_OUT_ID],
                   [...PaddingKKBit.sOut, PaddingKKBit.sOutId]);

    (1 - lastHash) * forceLastHash === 0;   // Force first block to be the beggining

    col witness len;
    len' * lastHash === rem' * lastHash;
    len' * (1-lastHash) === len* (1-lastHash);

    col witness hash[8];

    for (col &hash in hash) {
        (hash' - hash) * (1 - lastHash) === 0;
    }

    (addr' - addr) * (1-lastHash) === 0;
    (addr' - (addr + 1)) * lastHashLatch === 0;

    col witness incCounter;
    // if lastHash=0 && lastBLock=0 then incCounter'=incCounter
    // if lastHash=0 && lastBLock=1 then incCounter'=incCounter+1
    // if lastHash=1 && lastBlock=1 then incCounter'=1
    incCounter' === incCounter*(1-lastBlock) + (incCounter +1)*(lastBlock-lastHash) + lastHash;

    col witness crOffset;
    col witness crLen;

    col witness crOffsetInv;
    col crLatch = 1 - crOffset * crOffsetInv;
    crOffset * crLatch === 0;

    crOffset' * (1 - crLatch) === (crOffset - 1)*(1 - crLatch);
    crLen' * (1 - crLatch) === crLen*(1 - crLatch);
    crLatch * crOffset' === crLatch * (crLen' -1);

    col witness crF[8];

    lookup_check ([crOffset, ...crF],
                  [OFFSET, ...BYTE_FACTOR]);

    col witness crV[8];
    col crVC[8];
    for (int i = 0; i < 8; ++i) {           // IMPROVEMENT?: for (col [&crVC, &crV] in [crVC, crV])
        crVC[i] = crV[i] + crF[i] * aFreeIn;
        crV[i]' === crVC[i] * (1 - crLatch);
    }
    (1 - crLatch) * lastHash === 0;  // Ensure qhen a hash ends it resets the address.

    /* Read Data output
        crLatch * crValid {addr, PaddingKK.len - PaddingKK.rem - PaddingKK.crLen + 1, crLen, crV0C, crV1C, crV2C, crV3C, crV4C, crV5C, crV6C, crV7C}
    */

    /* Read Len output
        lastHashLatch {addr, len}
    */

    /* Read Len digest
        lastHashLatch { addr, hash0, hash1, hash2, hash3, hash4, hash5, hash6, hash7 }
    */
}