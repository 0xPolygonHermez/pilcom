include "global.pil";

namespace Main::Mem {

    col fixed STEP = [0..N-1];
    col fixed L_LAST = [0...,1];
    col INCS = STEP + 1;
    col ISNOTLAST = (1 - L_LAST);

    col witness addr;
    col witness step;
    col witness mOp, mWr;
    col witness val[8];
    col witness lastAccess; // 1 if its the last access of a given address

    // The list is sorted by [addr, step]

    lastAccess * (lastAccess - 1) === 0;
    lookup_check(ISNOTLAST,
                 [ lastAccess*(  addr' - addr - (step'-step) ) + (step'-step) ],
                 INCS);
    (1 - lastAccess) * (addr' - addr) === 0;

    mOp * (mOp -1) === 0;
    mWr * (mWr -1) === 0;
    // mWr could be 1 only if mOp is 1
    (1 - mOp) * mWr === 0;

    col isWrite = mOp' * mWr';
    col rdSame = (1-isWrite) * (1-lastAccess);
    col rdDifferent = (1-isWrite) * lastAccess;

    // lastAccess has to be 1 in the last evaluation. This is necessary to
    // validate [rdDifferent * (val[0]') = 0;] correctly (in a cyclic way)
    (lastAccess - 1) * (1 - ISNOTLAST) === 0;

    for (integer i = 0; i < 8; ++i) {
        rdSame * (val[i]' - val[i])  ===  0;
        // The first evaluation is successfully validated when the evaluation cycle is restarted
        rdDifferent * (val[i]')  ===  0;
    }
}