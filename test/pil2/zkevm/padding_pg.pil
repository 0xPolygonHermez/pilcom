// include "global.pil";
include "poseidong.pil";

namespace PaddingPG:: {

    constant BYTES_BLOCK = 56;
    constant BLOCKS = N \\ BYTES_BLOCK;

    col fixed F[8];
    col fixed OFFSET = [0..32]...;
    col fixed LAST_BLOCK = [[0:55, 1]:BLOCKS,0...,1];   // blocks of 56 steps, 0 in the first 55 steps and 1 in the last step of the block.
                                                        // Also the last global step was 1 to close the global cycle (allowing addr change from step N-1 to 0)
    col fixed CR_VALID = [1:56*BLOCKS,0...];            // 1 for valid/complete 56 steps blocks, 0 for last smaller/incomplete block

    // Polynomials that are used to compute a hash chunk
    col witness acc[8];
    col witness freeIn;
    col witness addr;
    col witness rem;                                    // rem: It can be different only the first byte of a new Hash.

    range_check(freeIn, 0, 255);
    rem' * (1-lastHash) === (rem-1)*(1-lastHash);

    col witness remInv;
    col remIsZero = 1 - rem*remInv;
    remIsZero * rem === 0;

    col witness spare;
    col lastHash = lastBlock*(spare + remIsZero);
    spare' === (spare + remIsZero)*(1-lastHash);
    spare * (1 - spare) === 0;

    col witness lastHashLen;
    col witness lastHashDigest;

    lastHashLen * (1 - lastHashLen) === 0;
    lastHashDigest * (1 - lastHashDigest) === 0;

    lastHashLen * (1 - lastHash) === 0;
    lastHashDigest * (1 - lastHash) === 0;

    col aFreeIn = (1 - (remIsZero + spare))*freeIn + remIsZero + lastHash*0x80;

    col accC[8];
    for (i = 0; i < 8; ++i) {
        accC[i] = acc[i] + F[i] * aFreeIn;
        acc[i]' === accC[i] * (1 - LAST_BLOCK);
    }

    lookup_check(
        lastBlock,
        [...accC, ...prevHash, ...curHash],
        PoseidonG::LATCH,
        PoseidonG::[...value, hashType, ...cap, ...hash]
    );

    col witness curHash[4];
    col witness prevHash[4];

    for (i = 0; i < 4; ++i) {
        when (1 - LAST_BLOCK) { curHash[i]' === curHash[i] }
        prevHash[i]' === LAST_BLOCK * (curHash[i] - prevHash[i]) + prevHash[i] - lastHash * curHash[i];
    }

    col witness incCounter;
    // if lastHash=0 && lastBLock=0 then incCounter'=incCounter
    // if lastHash=0 && lastBLock=1 then incCounter'=incCounter+1
    // if lastHash=1 && lastBlock=1 then incCounter ===
    incCounter' === incCounter*(1-lastBlock) + (incCounter +1)*(lastBlock-lastHash) + lastHash;

    col witness len;
    len' * lastHash === rem' * lastHash;
    len'*(1-lastHash) === len*(1-lastHash);

    (addr' -addr) * (1-lastHash) === 0;

    col doInc = lastHash * (1-Global.L1');
    (addr' - 1 -addr) * doInc === 0;

    // chunkReader generator

    col witness crOffset;
    col witness crLen;

    col witness crOffsetInv;
    col crLatch = 1 - crOffset*crOffsetInv;
    crOffset * crLatch === 0;

    crOffset'*(1-crLatch) === (crOffset - 1)*(1-crLatch);
    crLen'*(1-crLatch) === crLen*(1-crLatch);
    crLatch * crOffset' === crLatch * (crLen' -1);

    col witness crF[8];
    lookup_check([crOffset, ...crF],
                 [OFFSET, ...BYTE_FACTOR]);     // ?¿?¿? BYTE_FACTOR[8]

    col crVC[8];
    col witness crV[8];
    for (i = 0; i < 8; ++i) {
        crVC[i] = crV[i] + crF[i] * aFreeIn;
        crV[i]' === crVC[i] * (1 - crLatch);
    }

    (1-crLatch) * lastHash === 0;  // Ensure when a hash ends it resets the address.

    /* Read Data output
        crLatch * crValid [hash0, hash1, hash2, hash3, hash4, hash5, hash6, hash7, crOffset - crLen -1, crLen, crV0C, crV1C, crV2C, crV3C, crV4C, crV5C, crV6C, crV7C]
    */

    /* Read Len output
        lastHash [hash0, hash1, hash2, hash3, hash4, hash5, hash6, hash7, len]
    */

}