include "byte4.pil";

constant ARITH_ID = 2;

subproof Arith(2**16) {

    col witness a[2], b[2], c[2], d[2];
    col witness carry[2];
    col witness result;

    col fixed CLK = [1,0:9]...;
    // col fixed CLK[10];
    // CLK[0] = [1, 0:9]...;
    // CLK[1] = [0, 1, 0:8]...;
    // CLK[9] = [0:9, 1]...;
    constant FACTOR = 2**32;

    a[0] * b[0] - carry[0] * FACTOR === c[0];
    a[1] * b[0] + a[0] * b[1] - carry[1] * FACTOR === c[1];
    a[1] * b[1] - d[1] * FACTOR === d[0];

    expr byte4col = 0;
    int index = 0;
    for (col witness &r in [...a,...b,...c,...d,...carry]) {
        (r'-r) * (1-CLK) === 0;
        // 0
        // 0 + CLK0 * a[0]
        // 0 + CLK0 * a[0] + CLK1 * a[1] + ...
        byte4col = byte4col + CLK'(index) * r;
        ++index;
    }
    // byte4col = CLK0 * a[0] + CLK1 * a[1] + CLK2 * b[0] + ...
    result * (1 - result) === 0;
    (result'-result) * (1-CLK) === 0;

    multiset_provide(ARITH_ID, result * CLK'9, [...a,...b,...c,...d]);
    multiset_require(BYTE4_ID, result, [byte4col]);
}