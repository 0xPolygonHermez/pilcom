constant MAX_MULTISET_ID=1000;

function subair_multiset_requires(int id, expr sel, expr cols[]) {
    subair_multiset(0, id, sel, cols);
}

function subair_multiset_provides(int id, expr sel, expr cols[]) {
    subair_multiset(1, id, sel, cols);
}

private function subair_multiset(int provides, int id, expr sel, expr cols[]) {
    // verify if correct id and cols
    check_multiset_id_and_cols(id, length(cols), provides);

    // TODO: use specific name, not match with other challenge
    init_multiset_challenges(0);

    // TODO: optimize to put only once this constraint if witness col, if cols are fixed
    // check on compilation time, constraint not needed.

    // TODO: optimization of constraints, at end review if expressions was fixed check on
    // compilation time the constraint
    sel * (1 - sel) === 0;

    // global is visible inside function vs static
    expr cols_compressed = 0;
    for (int icol = length(cols) - 1; icol >= 0; --icol) {
        cols_compressed = (cols_compressed + cols[icol]) * std_alpha;
    }

    // first extra col was id of multiset
    cols_compressed = cols_compressed + id;

    expr cols_selected = sel * (cols_compressed + std_beta - 1) + 1;

    if (provides) {
        // adding all products of provides called in this subair
        subair_multiset_gprod_provides = subair_multiset_gprod_provides * cols_selected ;
    } else {
        // adding all products of requires called in this subair
        subair_multiset_gprod_requires = subair_multiset_gprod_requires * cols_selected;
    }

    on final subair_multiset_instance_constraints();
    on final subair subair_multiset_subair_constraints();
    on final air subair_multiset_air_constraints();
}

private function init_multiset_challenges(int lookup)
{
    if (!defined(std_alpha)) {
        // TODO: could be challenge non global
        global challenge std_alpha stage(2);
        global challenge std_beta stage(2);
    }
}

// function to verify that number of columns of same multiset (requires, provides)
// was the same.

private function check_multiset_id_and_cols(int id, int _cols, int provides) {

    once air {
        int multiset_cols[MAX_MULTISET_ID + 1];
        int multiset_provides[MAX_MULTISET_ID + 1];
        int multiset_requires[MAX_MULTISET_ID + 1];

    }

    if (id < 1 || id > MAX_MULTISET_ID) {
        error("id of multiset must be between 1 and $0", MAX_MULTISET_ID);
    }
    if (_cols < 1) {
        error("number of cols of multiset #$0 must be greater than 0", id);
    }
    // non defined

    if (multiset_cols[id] == 0) {
        // TODO: G2 - structs
        multiset_cols[id] = _cols;
        // multiset_source[id] == __SOURCE__
    } else if (multiset_cols[id] != _cols) {
        error("number of cols of multiset #$0 must be $1", id, multiset_cols[id]);
    }

    if (provides) {
        ++multiset_provides[id];
    } else {
        ++multiset_requires[id];
    }

    once air {
        global expr subair_multiset_air_gprod = 1;
    }
    once subair {
        subair value aggregate(mul) subair_multiset_subair_gprod;
        // subair value subair_multiset_subair_gprod;
        // subair value subair_multiset_subair_gprod aggregate(prod) instance value subair_multiset_instance_gprod;
        // subair value subair_multiset_subair_gprod (subair_multiset_instance_gprod);
        // subair value subair_multiset_subair_gprod = recursive(1, self * subair_multiset_instance_gprod);
        // subair value subair_multiset_subair_gprod = [1, 'subair_multiset_subair_gprod * subair_multiset_instance_gprod, ...];
        // subair value subair_multiset_subair_gprod = recursive(1, 'subair_multiset_subair_gprod * subair_multiset_instance_gprod);
        // subair value subair_multiset_subair_gprod = 1, 'subair_multiset_subair_gprod * subair_multiset_instance_gprod,...
        // subair value subair_multiset_subair_gprod = (1, 'subair_multiset_subair_gprod * subair_multiset_instance_gprod);
    }
    once {
        global expr subair_multiset_gprod_requires = 1;
        global expr subair_multiset_gprod_provides = 1;
    }
}

private function subair_multiset_instance_constraints() {

    // TODO: allow use defined constants as stage id.
    col witness gprod stage(3);

    //                     (requires_selected + std_gamma)
    //  gprod === 'gprod * ----------------------------
    //                     (provides_selected + std_gamma)


    col fixed L1 = [1,0...]; // compiler optimize and only exists one L1

    col gprod2 = 'L1 * ( 1 - gprod) + gprod;

    // constraint instance_value with grand product

    gprod2 * subair_multiset_gprod_provides === 'gprod2 * subair_multiset_gprod_requires;

    L1 * 'gprod === subair_multiset_subair_gprod;
}

private function subair_multiset_subair_constraints() {
    // subair_multiset_air_gprod = subair_multiset_air_gprod * subair_multiset_instance_gprod;
    subair_multiset_air_gprod = subair_multiset_air_gprod * subair_multiset_subair_gprod;
}

private function subair_multiset_air_constraints() {
    check_subair_multiset_was_complete();

    subair_multiset_air_gprod === 1;
}

private function check_subair_multiset_was_complete() {
    for (int index = 0; index < MAX_MULTISET_ID; ++index) {
        if (multiset_cols[index] == 0) continue;
        if (multiset_requires[index] == 0) {
            error("multiset #$0 defined without requires", id);
        }
        if (multiset_provides[index] == 0) {
            error("multiset #$0 defined without provides", id);
        }
    }
}
