// TODO: Optimization. Do the batching of multiple multiset/lookup checks to the same table

private function init_challenges() {
    if (!defined(std_alpha)) {
        challenge stage(2) std_alpha;
    } else if (!defined(std_beta)) {
        challenge stage(2) std_beta;
    }
}

function multiset_require(int opid, expr sel, expr cols[]) {
    piop_update(0, opid, sel, cols);
}

function multiset_provide(int opid, expr sel, expr cols[]) {
    piop_update(1, opid, sel, cols);
}

function lookup_require(int opid, expr sel, expr cols[]) {
    piop_update(0, opid, sel, cols);
}

function lookup_provide(int opid, expr sel, expr cols[]) {
    piop_update(1, opid, sel, cols);
}

/**
 * Verifies the number of columns of same PIOP check (require, provide) is the same.
 * @param opid (unique) identifier of the PIOP check
 * @param cols_count number of columns of the PIOP check
 * @param provide 1 if provide, 0 if require
 */
private function check_id_and_cols(int opid, int cols_count, int provide) {

    if (cols_count < 1) {
        error(`The number of columns of PIOP #${opid} must be at least 1`);
    }

    container proof.std.piop alias piop {
        int opids[];
        expr gsum = 0;
    }

    container subproof.std.piop {
        subproofval aggregate(sum) gsum_result;
    }

    container air.std.piop {
        expr gsum_require_mul_count[];
        expr gsum_require[];
        expr gsum_provide_mul_count[];
        expr gsum_provide[];
    }

    container proof.std.piop.`id${opid}` alias piopid {
        int cols;
        int provide;
        int require;
    }

    if (piopid.cols == 0) {
        // first time called
        piopid.cols = cols_count;
        // add opid on a list to verify at final
        piop.opids[] = opid;
    } else if (piopid.cols != cols_count) {
        error(`The number of columns of PIOP #${opid} must be ${piopid.cols}`);
    }

    if (provide) {
        if (piopid.provide > 0) {
            error(`PIOP #${opid} provide was called previously`);
        }
        ++piopid.provide;
    } else {
        if (piopid.require > 0) {
            error(`PIOP #${opid} provide was called previously`);
        }
        ++piopid.require;
    }
}

/**
 * Given columns C₁,...,Cₙ, reduces the vector PIOP to a single column PIOP.
 * @param opid (unique) identifier of the PIOP
 * @param cols columns of the PIOP
 * @return [opid + C₁·α + C₂·α² + ... + Cₙ·αⁿ] + β
 */
function compress_cols(int opid, expr cols[]): expr {
    expr cols_compressed = 0;
    for (int icol = length(cols) - 1; icol >= 0; --icol) {
        cols_compressed = (cols_compressed + cols[icol]) * std_alpha;
    }

    // the opid is added to avoid soundness issues between different PIOP checks
    cols_compressed = (cols_compressed + opid) + std_beta;
    return cols_compressed;
}

/**
 * Given columns C₀,...,Cₙ₋₁, and multiplicity counter M, it 1] defines the constraints at the air level, 2] updates the values at the subproof level, and 3] updates the constraints at the proof level.
 * @param provide boolean indicating if updating a provide or a require
 * @param opid (unique) identifier of the PIOP
 * @param mul_count multiplicity counter of the PIOP
 * @param cols columns of the PIOP
 */
function piop_update(int provide, int opid, expr mul_count, expr cols[]) {
    // verify if correct opid and cols
    check_id_and_cols(opid, length(cols), provide);

    init_challenges();

    // selected vector to simple column reduction
    expr cols_compressed = compress_cols(opid, cols);

    use air.std.piop;
    if (provide) {
        // adding all sums of provide called in this air
        gsum_provide_mul_count[] = mul_count;
        gsum_provide[] = cols_compressed;
    } else {
        // adding all sums of require called in this air
        gsum_require_mul_count[] = mul_count;
        gsum_require[] = cols_compressed;
    }

    // 1] define constraints at the air level
    on final air PIOP_air();

    // 2] update values at the subproof level
    on final subproof PIOP_subproof();

    // 3] update constraints at the proof level
    on final proof PIOP_proof();
}

private function PIOP_air() {
    use air.std.piop;

    col witness stage(3) gsum;

    //                                mt1       mt2       mt3       mf1       mf2       mf3            
    //  gsum === 'gsum * (1 - L1) + ------- + ------- + ------- - ------- - ------- - -------
    //                                t1        t2        t3        f1        f2        f3     

    col fixed L1 = [1,0...];

    expr LHS = 1;
    expr RHS1 = 0;
    for (int i = 0; i < length(gsum_provide); ++i) {
        LHS = LHS * gsum_provide[i];

        RHS1 = RHS1 + gsum_provide_mul_count[i];
        for (int j = 0; j < length(gsum_provide); ++j) {
            if (j == i) continue;
            RHS1 = RHS1 * gsum_provide[j];
        }
    }

    expr RHS2a = LHS;
    expr RHS2b = 0;
    for (int i = 0; i < length(gsum_require); ++i) {
        LHS = LHS * gsum_require[i];
        RHS1 = RHS1 * gsum_require[i];

        RHS2b = RHS2b + gsum_require_mul_count[i];
        for (int j = 0; j < length(gsum_require); ++j) {
            if (j == i) continue;
            RHS2b = RHS2b * gsum_require[j];
        }
    }

    expr RHS2 = RHS2a * RHS2b;
    expr RHS = RHS1 - RHS2;

    (gsum - 'gsum * (1 - L1)) * LHS === RHS;
    L1' * (gsum - subproof.std.piop.gsum_result) === 0;
}

private function PIOP_subproof() {
    proof.std.piop.gsum = proof.std.piop.gsum + subproof.std.piop.gsum_result;
}

private function PIOP_proof() {
    check_was_completed();

    proof.std.piop.gsum === 0;
}

private function check_was_completed() {
    for (int opid in proof.std.piop.opids) {
        if (proof.std.piop.`id${opid}`.require == 0) {
            error(`PIOP #${opid} defined without require`);
        }
        if (proof.std.piop.`id${opid}`.provide == 0) {
            error(`PIOP #${opid} defined without provide`);
        }
    }
}