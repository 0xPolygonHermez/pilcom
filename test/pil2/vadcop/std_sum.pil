// Do the batching of multiple multiset/lookup checks to the same table

constant MAX_OPIDS = 200;

private function init_challenges() {
    if (!defined(std_alpha)) {
        challenge stage(2) std_alpha;
    } else if (!defined(std_beta)) {
        challenge stage(2) std_beta;
    }
}

function multiset_require(int opid, expr sel, expr cols[]) {
    arg_update(0, opid, sel, cols);
}

function multiset_provide(int opid, expr sel, expr cols[]) {
    arg_update(1, opid, sel, cols);
}

function lookup_require(int opid, expr sel, expr cols[]) {
    arg_update(0, opid, sel, cols);
}

function lookup_provide(int opid, expr sel, expr cols[]) {
    arg_update(1, opid, sel, cols);
}

/**
 * Verifies the number of columns of same arg check (require, provide) is the same.
 * @param opid (unique) identifier of the arg check
 * @param _cols number of columns of the arg check
 * @param provide 1 if provide, 0 if require
 */
private function check_id_and_cols(int opid, int cols_count, int provide) {

    once proof int args_count;
    once proof int args_opids[MAX_OPIDS];

    scope persistent proof `std.arg.${opid}` {
        once scope int args_cols;
        once scope int args_provide;
        once scope int args_require;

        if (cols_count < 1) {
            error(`number of cols of arg #${opid} must be greater than 0`);
        }

        if (args_cols == 0) {
            // first time called
            args_cols = cols_count;
            // add opid on a list to verify at final
            push_id(opid);
        } else if (args_cols != cols_count) {
            error(`number of cols of arg #${opid} must be ${args_cols}`);
        }

        if (args_provide == 1) {
            ++args_provide;
        } else {
            ++args_require;
        }

        once proof expr proof_gsum = 0;
        once subproof value aggregate(sum) subproof_gsum;
        once air expr gsum_require_mul_count[MAX_OPIDS];
        once air expr gsum_require[MAX_OPIDS];
        once air expr gsum_provide_mul_count[MAX_OPIDS];
        once air expr gsum_provide[MAX_OPIDS];
    }
}


private function push_id(int opid) {

    if (args_count == MAX_OPIDS) {
        error(`too many arg opids, current limit was MAX_OPIDS(${MAX_OPIDS})`);
    }
    args_opids[args_count++] = opid;
}

/**
 * Given columns C₁,...,Cₙ, reduces the selected vector argument to a single column argument.
 * @param opid (unique) identifier of the argument
 * @param cols columns of the argument
 * @return [opid + C₁·α + C₂·α² + ... + Cₙ·αⁿ] + β
 */
function compress_cols(int opid, expr cols[]): expr {
    expr cols_compressed = 0;
    for (int icol = length(cols) - 1; icol >= 0; --icol) {
        cols_compressed = (cols_compressed + cols[icol]) * std_alpha;
    }

    // the opid is added to avoid soundness issues between different arg checks
    cols_compressed = (cols_compressed + opid) + std_beta;
    return cols_compressed;
}

/**
 * Given columns C₀,...,Cₙ₋₁, and multiplicity counter M, it 1] defines the constraints at the air level, 2] updates the values at the subproof level, and 3] updates the constraints at the proof level.
 * @param provide boolean indicating if updating a provide or a require
 * @param opid (unique) identifier of the argument
 * @param mul_count multiplicity counter of the argument
 * @param cols columns of the argument
 */
function arg_update(int provide, int opid, expr mul_count, expr cols[]) {
    // verify if correct opid and cols
    check_id_and_cols(opid, length(cols), provide);

    init_challenges();

    // selected vector to simple column reduction
    expr cols_compressed = compress_cols(opid, cols);

    if (provide) {
        // adding all sums of provide called in this air
        // gsum_provide = gsum_provide + mul_count / cols_compressed;
        gsum_provide_mul_count[args_provide] = mul_count;
        gsum_provide[args_provide] = cols_compressed;
    } else {
        // adding all sums of require called in this air
        // gsum_require = gsum_require + mul_count / cols_compressed;
        gsum_require_mul_count[args_require] = mul_count;
        gsum_require[args_require] = cols_compressed;
    }

    // 1] define constraints at the air level
    on final air air_constraints();

    // 2] update values at the subproof level
    on final subproof subproof_update();

    // 3] update constraints at the proof level
    on final proof proof_constraints();
}

private function air_constraints() {
    col witness stage(3) gsum;

    //                                mt1       mt2       mt3       mf1       mf2       mf3            
    //  gsum === 'gsum * (1 - L1) + ------- + ------- + ------- - ------- - ------- - -------
    //                                t1        t2        t3        f1        f2        f3     

    col fixed L1 = [1,0...];

    expr LHS = 1;
    expr RHS1 = 0;
    for (int i = 0; i < length(gsum_provide); ++i) {
        LHS = LHS * gsum_provide[i];

        RHS1 = RHS1 + gsum_provide_mul_count[i];
        for (int j = 0; j < length(gsum_provide); ++j) {
            if (j == i) continue;
            RHS1 = RHS1 * gsum_provide[j];
        }
    }

    expr RHS2a = LHS;
    expr RHS2b = 0;
    for (int i = 0; i < length(gsum_require); ++i) {
        LHS = LHS * gsum_require[i];
        RHS1 = RHS1 * gsum_require[i];

        RHS2b = RHS2b + gsum_require_mul_count[i];
        for (int j = 0; j < length(gsum_require); ++j) {
            if (j == i) continue;
            RHS2b = RHS2b * gsum_require[j];
        }
    }

    expr RHS2 = RHS2a * RHS2b;
    expr RHS = RHS1 - RHS2;

    (gsum - 'gsum * (1 - L1)) * LHS === RHS;
    L1' * (gsum - subproof_gsum) === 0;
}

private function subproof_update() {
    proof_gsum = proof_gsum + subproof_gsum;
}

private function proof_constraints() {
    check_was_completed();

    proof_gsum === 0;
}

private function check_was_completed() {
    for (int index = 0; index < args_count; ++index) {
        int opid = args_opids[index];
        scope persistent proof `std.arg.${opid}` {
            if (args_require == 0) {
                error(`arg #${opid} defined without require`);
            }
            if (args_provide == 0) {
                error(`arg #${opid} defined without provide`);
            }
        }
    }
}