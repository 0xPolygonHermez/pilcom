// -----------------------------------------------
// VADCOP support
subair aggregate Main (2**25) {

    // optional namespace
    namespace Mem {

    }

    // optional namespace
    namespace Rom {

    }
}
subair aggregate Arith(2**20,2**23,2**25) {

}

subair aggregate Binary(2**23,2**25) {

}

// subproof

// -----------------------------------------------
// Constructive language (runtime types)

int number_without_limits;
fe field_element;
expr to_build_constraints;
string for_development;

// constants
constant PIWEI = 3141592653589793238;

// arrays
int number_without_limits[10][20];
expr to_build_constraints[16];
constant MY_NUMBERS[8] = [2,3,5,7,11,13,17,19];
constant MATRIX[2][8] = [[1,3,5,7,9,11,13,15],
                         [2,4,6,8,10,12,14,18]];

// references
int &currentvalue = myvalue;
fe &pos = current_pos;

// -----------------------------------------------
// Constructive language (other types)

// col types
col intermediate_col;
col fixed fixed_col;
col witness witness_col;

// proof types
public batch_num;
challenge gamma;

// vadcop types
air value finalresult;
subair value aggregate(mul) multiset;

// arrays
col intermediate_col[10];
col witness witness_col[i*2];

// references
col &current_col = intermediate_col;
// col references could be reference to intermediate, fixed or witness
col &current_witness_col = witness_col;
col &current_fixed_col = fixed_col;
col witness &last_witness_col = witness_col;

// -----------------------------------------------
// Constructive language (control)

col fixed CLK32 = [0:31,1]...;
col witness x1[16], y1[16], x2[16], y2[16], x3[16], y3[16];
col witness s, q[3][16];

// Latch
for (int i = 0; i<16; ++i) {
   for(col &p in [x1,y1,x2,y2,x3,y3,s,q[0],q[1],q[2]]) {
       p[i]' * (1 - CLK32) === p[i] * (1 - CLK32);
   }
}

col witness flags[4];
for (col &flag in flags) {
    flag * (1 - flag) === 0;
}

int index = 0;
while (index < length(flags)) {
    flags[index] * (1 - flags[index]) === 0;
    ++index;
}

// -----------------------------------------------
// Constructive language (control 2)

int index = 0;
while (index < 5) {
    if (index < 0) break;           // break could be used on for,do,while,switch-case
    if (index % 2 == 0) continue;   // continue could be used on for,do,while
}

do {
    // do something
} while (++index < 10)

if (value != current_value) {
    // do something
} else {
    // do something else
}

// switch-case without break
switch (key) {
    case 1:
        value++;
    case 3,16:
        value = 13;
    case 8..15:
        value = 17;
    case 17,20..31,33:
        value = 19;
    else:
        value = 0;
}

// -----------------------------------------------
// Constructive language (example)

int nbits = log2(N);                                // log2 is a buildin function

col witness lJmpnCondValue;                         // first nbits of conditional value
col jmpnCondValue = JMPN*(isNeg*2**32 + op0);       // verified using plookup with STEP

isNeg * (1 - isNeg) === 0;                          // binary constraint

col witness hJmpnCondValueBit[32 - nbits];
fe factor = nbits;
expr condValue = lJmpnCondValue;
for (col &currentBit in hJmpnCondValueBit) {
    currentBit * (1 - currentBit) === 0;        // binary constraint
    condValue += 2**factor * currentBit;        // building condValue adding bits
    ++factor;
}
jmpCondValue === condValue;


// -----------------------------------------------
// Constructive language (example)

integer nbits = log2(N);                            // log2 is a buildin function

col witness lJmpnCondValue;                         // first nbits of conditional value
col jmpnCondValue = JMPN*(isNeg*2**32 + op0);       // verified using plookup with STEP

isNeg * (1 - isNeg) === 0;                          // binary constraint

col witness hJmpnCondValueBit[32 - nbits];
fe factor = nbits;
expr condValue = lJmpnCondValue;
for (col &currentBit in hJmpnCondValueBit) {
    currentBit * (1 - currentBit) === 0;        // binary constraint
    condValue += 2**factor * currentBit;        // building condValue adding bits
    ++factor;
}
expr c = a / b;

jmpCondValue === condValue;

// -----------------------------------------------
// Conditional / Boundary constraints

// Conditional constraints
when L1 {
    a === a',
    b === b'
}

for (integer index = 0; index < 16; ++index) {
   when (1-L1) { a[index] === b[index] + (1 - c) } // when only contains constraints
}

// Boundary constraints (last,first)
when last {
    d * e === a
}

when not last { d * e === a }
when first { d * e === a }
when not first { d * e === a }

// -----------------------------------------------
// Constructive language (functions)

function factorial (int n) : int {
    if (n == 1) return 1;
    return n * factorial(n-1);
}

function myfunc (expr &selector, expr cols[]) { ... }     // arrays and references

function sum(...) : int {                  // number variable of parameters
    int total = 0;
    for (int index = 0; index < length(args); ++index) {
        if (!(args[index] is int)) error("sum: invalid parameter #$0, it must be an integer", index);
        total += args[index];
    }
    return total;
}

function swap(int a, int b) : [int, int] { ... } // multiple returns
function swap(string a, string b) : [string, string] { .... }    // parametric polymorphism (overloading)
function next3(int a) : [int,int, int] { return [a+1,a+2,a+3]; }

[c,] = swap(a,b);       // ignore one return value
[c,...] = next3(10);    // ignore rest of return values
[n1,,n3] = next3(k);    // ignore one return value


// -----------------------------------------------
// Constructive language (deferred functions)

// called each time that one instance finish
final function on_instance_final_was_called (){
}

// called each time that one subair finish
final subair function on_subair_final_was_called (){
}

// called at end
final air function on_instance_final_was_called (){
}

function myfunc (expr &selector, expr cols[]) {
    // only if function was executed
    // only one time by instance
    on final instance_finished_func(with_args);
    // only one time by subair
    on final subair subair_finished_func(arg1, arg2);
    // only one time is called
    on final air final_func(with_args);
}

// private functions, only visible inside same source file
private function internal_lib_helper() {
}
// -----------------------------------------------
// Constructive language (functions)

col fixed L1 = [1,0...];

when first c === 23;

when first {
  a === 0;
  b === 0;
}

when last {
  gprod === 1,
}

when frame {
    a'3 === a + a' + a'2;
}

when (1-L1) {
    for (integer index = 0; index < 16; ++index) {
        a[index] === b[index] + (1 - c);
    }
}

constant MAX_PUBLIC_TABLE_ROWS = 32;
constant PUBLIC_TABLE_COLS = 10;

function prodColyumns(rowElements) {
    expression expr = 0;
    for (int i=0; i<length(column; i++)) {
        expr = (expr + rowElements[i])*alfa;
    }
    return expr;
}



public table aggregate(prod, prodColumns) gprods[PUBLIC_TABLE_COLS][MAX_PUBLIC_TABLE_ROWS] ;

memory * gprod === 1
binary * gprod0[1] === 1;

// -----------------------------------------------
// Challenges access

col witness a1, a2, b1, b2;

col witness stage(2) h1, h2;
challenge stage(2) epsilon;
challenge stage(3) betas[4];

col f = a1 + epsilon * a2;
col t = b1 + epsilon * b2;

col witness stage(3) z;
challenge stage(3) delta, gamma;

when L1 {z === 1};

z' * ((delta*(1+gamma) + h1 + gamma*h2)) * ((delta*(1+gamma) + h2 + gamma*h1')) ===
   z * (1+gamma)*(delta + f)*(delta*(1+gamma) + t + gamma*t');

// -----------------------------------------------
// Fixed columns generation

// values and repetitions: [value1,value2,value3] [value:times]
// ranges negatives or positives: [from..to] [from:times..to:times]
// repeat up to full:  [value...]
// arithmetic series: [first,second,..+..] [first,second,..+..,last]
// geometric series:  [first,second,..*..] [first,second,..*..,last]

col fixed L1 = [1,0...];            // [1,0:N-1]
col fixed L_LAST = [0...,1];        // [0:N-1,1]

col fixed J = [0:3..127:3,128:2..255:2]...; // 0,0,0,1,1,1,2,2,2,3...127,128,128,129...,254,255,255,0,0,0,1,1,...
col fixed K = [[0,1,2,3]:3, [4,5,6]:2]...;  // 0,1,2,3,0,1,2,3,0,1,2,3,4,5,6,4,5,6,0,1,2,3...
col fixed ODDS = [1,3,..+..];               // 1,3,5,7,9,11,13,15,17,19,21,23,25,...
col fixed FACTOR = [1,2,..*..,2**32]...;    // 1,2,4,8,16,32,64,128,256,512,1024,2048,....,2**31,2**32,1,2,4,...

// using constructive language
col fixed F;
F[0] = 0;
F[1] = 1;
for (int i=2; i<N; ++i) {
   F[i] = F[i-1] + F[i-2];
}


// -----------------------------------------------
// Previous and next rows access

// <n>'<col>        'LATCH, 2'LATCH,
// <col>'<n>        LATCH', LATCH'2,
// (<exp>)'<col>    (i+1)'LATCH
// <col>'(<exp>)    LATCH'(i+1)

4'carry === 0;
carry'4 === 0;

col fixed FACTOR0 = [1,2**8,2**16,2**24,0:28]....;
col FACTOR[8];     // FACTOR[0] = [1,2**8,2**16,2**24,0:28]....
                   // FACTOR[1] = [0:4,1,2**8,2**16,2**24,0:24]....
                   //    :
                   // FACTOR[7] = [0:28,1,2**8,2**16,2**24]....

for (integer i=0; i<7; i++) {
   FACTOR[i] = FACTOR0'(i*4);
}

// -----------------------------------------------
// Previous and next rows access (cont)

col witness abc[8];

expr expr_abc[3];
for (integer i = 0; i < 16; ++i) {
   integer j = i*4;
   when LATCH {   // LATCH = CLK15
         abc[i] ===   (j)'freeInA[0]         + (j-1)'freeInA[1] * 2**8 +       // CLK15
                    (j-2)'freeInA[0] * 2**16 + (j-3)'freeInA[1] * 2**24;

        'abc[i] ===   (j)'freeInB[0]         + (j-1)'freeInB[1] * 2**8 +       // CLK14 == 'LATCH
                    (j-2)'freeInB[0] * 2**16 + (j-3)'freeInB[1] * 2**24;

       2'abc[i] ===   (j)'freeInC[0]         + (j-1)'freeInC[1] * 2**8 +       // CLK13 == 2'LATCH
                    (j-2)'freeInC[0] * 2**16 + (j-3)'freeInC[1] * 2**24;
   }
}


// -----------------------------------------------
// Range checks

col witness sel;
col witness a,b;

range_check(sel, a, 0, 2**16-1);
range_check(b, 0, 255);

col witness c[32];
expr clkC;
for (integer index = 0; index < 32; ++index) {
    clkC = clkC + CLK32[index] * c[i];
    when (1-RESET) c[i]' === c[i];
}
range_check(clkC, 0, 255);

// -----------------------------------------------
// Custom data

function lookup_check (expr selF, expr colsF[], expr selT, expr colsT[]) {
   @lookup {selF:selF, colsF:colsF, selT:selT, colsT: colsT};
}

// to extend to new features
function myfuturefunc (expr v) {
   @myfuturefunc {colsF: v}
}

// front-end data could be more complex as key: value or combinations
function lookup (expr selF, expr colsF[], expr selT, expr colsT[]) {
   @the_name_that_I_want {selF: 1,     // keys aren't resolved
             colsF: colsF,             // values resolved (value, expression or column reference)
             selT: 1,
             colsT: colsT};
}


// -----------------------------------------------
// Buildin functions

// builtin variables
N                                           // key with number of rows
BITS                                        // key with bits of N
PRIME                                       // key with prime of fe
SOURCE                                      // string with source reference (pil)

print("hello");                                 // print values without LF
println(" world my name is", name);             // same as print but with LF
warning("number $0 too big, be careful", i);    // show warning but continue
error("division by zero");                      // show error and doesn't continue
assert(expected == res, "invalid result");      // if conditions was false then show error and doesn't continue

namespace_of(A)                             // return namespace of A (string)
subair_of(A)                                // return subproof of A (string)
stage_of(A)                                 // return stage of A (integer)
length(A)                                   // return length of array (integer) or length of string
dim(A)                                      // return number of dimensions
log2(N)                                     // return log2 of N
is_array(A)                                 // return if A is an array
defined(A)                                  // return if A is declared and defined

A is fe                                     // return if A is an fe (could be used with other types)
A is expr[]                                 // return if A is an array of expressions

`template string ${N}`                      // template string




// custom data  provides extra information to nexts steps (backend)
function lookup_check (expr selF, expr colsF[], expr selT, expr colsT[]) {
    @lookup_check [selF, colsF, selT, colsT];
}

// to extend to new features
function myfuturefunc (expr value) {
    @myfuturefunc value
}

// custom data could be more complex as key: value or combinations
function lookup_check (expr selF, expr colsF[], expr selT, expr colsT[]) {
    @the_name_that_I_want {selF: 1,     // keys aren't resolved
              colsF: colsF,             // values resolved (value, expression or column reference)
              selT: 1,
              colsT: colsT};
}

// -----------------------------------------------
// Lookup

lookup_check (
   hashK + hashK1,
       [ addr,
         op0, op1, op2, op3
       ],
   PaddingKK.crLatch * PaddingKK.r8valid,
       [
         PaddingKK.addr,
         PaddingKK.crV0C, PaddingKK.crV1C, PaddingKK.crV2C, PaddingKK.crV3C
       ]
   );

function lookup_check (expr selF, expr colsF[], expr selT, expr colsT[]) {
   setup_L1();
   @lookup_check { selF: selF, colsF: colsF, selT: colsT }
}

function setup_L1() {
   if (!(L1 is col)) {
       global col fixed L1 = [1,0...];
   }
}

// -----------------------------------------------
// Lookup

lookup_check (
   hashK + hashK1,
       [ addr,
         op0, op1, op2, op3
       ],
   PaddingKK.crLatch * PaddingKK.r8valid,
       [
         PaddingKK.addr,
         PaddingKK.crV0C, PaddingKK.crV1C, PaddingKK.crV2C, PaddingKK.crV3C
       ]
   );

optional col fixed L1;

function lookup_check (expr selF, expr colsF[], expr selT, expr colsT[]) {
   setup_L1();
   @lookup_check { selF: selF, colsF: colsF, selT: colsT }
}

function setup_L1() {
   if (!defined(L1)) L1 = [1,0...];
}

// -----------------------------------------------
// Example: match

s === match(selEq,
    1, x1[0],
    2, x2[0],
    3, y2[0]
);

function match (col sel, ...) : expr {

    @match {selector: sel, cases: args}

    integer argc = length(args);
    if (length(args) % 2 != 0) {
        error(`match was called with number incorrect ${argc}`);
    }
    for (integer icase = 0; icase < argc; icase = icase + 2) {
        if (!(args[icase] is fe)) error(`selector must be a constant value on ${icase}`);
        if (!(args[icase+1] is expr)) error(`expression must be a constant value on ${icase}`);
    }

    expr bc, res;
    integer cases = argc \ 2;
    col L[argc \ 2];
    for (integer icase = 0; icase < argc; icase = icase + 2) {
        expr lexpr;
        fe invl = 1;
        fe csel = args[icase]
        expr cexpr = args[icase + 1];

        for (integer j = 0; j < cases; ++j) {
            if (i == j) continue;
            lexpr = lexpr * (sel * args[2 * j]);
            invl = invl * (csel - args[2 * j]);
        }

        bc = bc * (sel - csel);
        L[icase] = lexpr / invl;
        res = res + L[icase] * cexpr;
    }
    bc === 0;
    return res;
}

lookup_check (
    hashK + hashK1,
        [ addr,
          op0, op1, op2, op3,
        ],
    PaddingKK.crLatch * PaddingKK.r8valid,
        [
          PaddingKK.addr,
          PaddingKK.crV0C, PaddingKK.crV1C, PaddingKK.crV2C, PaddingKK.crV3C,
        ]
    );

optional col fixed L1;

function lookup_check (expr selF, expr colsF[], expr selT, expr colsT[]) {
    col L1 = setup_L1();
    @lookup { selF: selF, colsF: colsF, selT: colsT }
}

// declared, defined
function setup_L1() {
    col fixed L1 = [1,0...];
    return L1;
}

function next() {
    static integer counter = 0;
    return counter++;
}


permutation_check (
    hashK + hashK1,
        [ addr,
          op0, op1, op2, op3,
        ],
    PaddingKK.crLatch * PaddingKK.r8valid,
        [
          PaddingKK.addr,
          PaddingKK.crV0C, PaddingKK.crV1C, PaddingKK.crV2C, PaddingKK.crV3C,
        ]
    );

function permutation_check (expr selF, expr colsF[], expr selT, expr colsT[]) {
    setup_L1();
    @permutation_check { selF: selF, colsF: colsF, selT: colsT }
}

function permutation_check (expr colsF[], expr colsT[]) {
    permutation_check(1, colsF, 1, colsT);
}

subproof_permutation_check (
    hashK + hashK1,
        [ addr,
          op0, op1, op2, op3,
        ],
    spKeccak::PaddingKK.crLatch * spKeccak::PaddingKK.r8valid,
        [
          spKeccak::PaddingKK.addr,
          spKeccak::PaddingKK.crV0C, spKeccak::PaddingKK.crV1C, spKeccak::PaddingKK.crV2C, spKeccak::PaddingKK.crV3C,
        ]
    );

function subproof_permutation_check (expr selF, expr colsF[], subproof::expr selT, subproof::expr colsT[]) {
    setup_L1();
    @permutation_check { selF: selF, colsF: colsF, selT: colsT }
    string tSubproof = subproof_of(selT);
    for (subproof::expr &t in colsT) {
        if (subproof_of(t) != tSubproof) error("merda");
    }
    if (subproof_of(selT) == tSubproof)
}

function permutation_check (expr colsF[], subproof::expr colsT[]) {
    permutation_check(1, colsF, 1, colsT);
}

c = connection_check([a,b,c],[A,B,C]);
c.connect([a, 32*index + 3, b, 32*index +4]);
c.repeat_cycle(32);


col witness a,b,c;
col mutable fixed A,B,C;

connection_setup([A,B,C]);

// cyclic example
integer count = N/32;
for (integer index = 0; index < count; ++index) {
    connection_connect([a, 32*index + 3, b, 32*index +4], [A,B,C]);
    connection_connect([a, 32*index +2, c, 32*index +5, b, 32*index +7], [A,B,C]);
}

// shift example
for (integer index = 0; index < N; ++index) {
    connection_connect([a, index, b, index+1], [A,B,C]);
}

connection_check([a,b,c],[A,B,C]);


/*
   expressions representation

operation = 5 bits = 32 operations
operands = number, stack (relative_offset), reference (expression, col, etc.. or all was an expression)

combinations of operands = 3 * 3 = 9 but number op number no sense, 8 valid combinations = 3 bits

5 bits + 3 bits = 1 byte.
number = 32 bytes.
stack, reference = 3 bytes => 16.7 million of references
TOTAL = 36 bytes (32 bits aligned)

results in parallel stack, array of 32 bytes.

expression of 10240 operations = 360K (expressions) + 320K (results)
*/

