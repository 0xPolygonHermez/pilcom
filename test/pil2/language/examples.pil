// -----------------------------------------------
// VADCOP support
subair aggregate Main (2**25) {

    // optional namespace
    namespace Mem {

    }

    // optional namespace
    namespace Rom {

    }
}
subair aggregate Arith(2**20,2**23,2**25) {

}

subair aggregate Binary(2**23,2**25) {

}

// subproof

// -----------------------------------------------
// Constructive language (runtime types)

int number_without_limits;
fe field_element;
expr to_build_constraints;
string for_development;

// constants
constant PIWEI = 3141592653589793238;

// arrays
int number_without_limits[10][20];
expr to_build_constraints[16];
constant MY_NUMBERS[8] = [2,3,5,7,11,13,17,19];
constant MATRIX[2][8] = [[1,3,5,7,9,11,13,15],
                         [2,4,6,8,10,12,14,18]];

// references
int &currentvalue = myvalue;
fe &pos = current_pos;

// -----------------------------------------------
// Constructive language (other types)

// col types
col intermediate_col;
col fixed fixed_col;
col witness witness_col;

// proof types
public batch_num;
challenge gamma;

// vadcop types
air value finalresult;
subair value aggregate(mul) multiset;

// arrays
col intermediate_col[10];
col witness witness_col[i*2];

// references
col &current_col = intermediate_col;
// col references could be reference to intermediate, fixed or witness
col &current_witness_col = witness_col;
col &current_fixed_col = fixed_col;
col witness &last_witness_col = witness_col;

// -----------------------------------------------
// Constructive language (control)

col fixed CLK32 = [0:31,1]...;
col witness x1[16], y1[16], x2[16], y2[16], x3[16], y3[16];
col witness s, q[3][16];

// Latch
for (int i = 0; i<16; ++i) {
   for(col &p in [x1,y1,x2,y2,x3,y3,s,q[0],q[1],q[2]]) {
       p[i]' * (1 - CLK32) === p[i] * (1 - CLK32);
   }
}

col witness flags[4];
for (col &flag in flags) {
    flag * (1 - flag) === 0;
}

int index = 0;
while (index < length(flags)) {
    flags[index] * (1 - flags[index]) === 0;
    ++index;
}

// -----------------------------------------------
// Constructive language (control 2)

int index = 0;
while (index < 5) {
    if (index < 0) break;           // break could be used on for,do,while,switch-case
    if (index % 2 == 0) continue;   // continue could be used on for,do,while
}

do {
    // do something
} while (++index < 10)

if (value != current_value) {
    // do something
} else {
    // do something else
}

// switch-case without break
switch (key) {
    case 1:
        value++;
    case 3,16:
        value = 13;
    case 8..15:
        value = 17;
    case 17,20..31,33:
        value = 19;
    else:
        value = 0;
}

// -----------------------------------------------
// Constructive language (example)

int nbits = log2(N);                                // log2 is a buildin function

col witness lJmpnCondValue;                         // first nbits of conditional value
col jmpnCondValue = JMPN*(isNeg*2**32 + op0);       // verified using plookup with STEP

isNeg * (1 - isNeg) === 0;                          // binary constraint

col witness hJmpnCondValueBit[32 - nbits];
fe factor = nbits;
expr condValue = lJmpnCondValue;
for (col &currentBit in hJmpnCondValueBit) {
    currentBit * (1 - currentBit) === 0;        // binary constraint
    condValue += 2**factor * currentBit;        // building condValue adding bits
    ++factor;
}
jmpCondValue === condValue;


// -----------------------------------------------
// Constructive language (example)

integer nbits = log2(N);                            // log2 is a buildin function

col witness lJmpnCondValue;                         // first nbits of conditional value
col jmpnCondValue = JMPN*(isNeg*2**32 + op0);       // verified using plookup with STEP

isNeg * (1 - isNeg) === 0;                          // binary constraint

col witness hJmpnCondValueBit[32 - nbits];
fe factor = nbits;
expr condValue = lJmpnCondValue;
for (col &currentBit in hJmpnCondValueBit) {
    currentBit * (1 - currentBit) === 0;        // binary constraint
    condValue += 2**factor * currentBit;        // building condValue adding bits
    ++factor;
}
expr c = a / b;

jmpCondValue === condValue;

// -----------------------------------------------
// Conditional / Boundary constraints

// Conditional constraints
when L1 {
    a === a',
    b === b'
}

for (integer index = 0; index < 16; ++index) {
   when (1-L1) { a[index] === b[index] + (1 - c) } // when only contains constraints
}

// Boundary constraints (last,first)
when last {
    d * e === a
}

when not last { d * e === a }
when first { d * e === a }
when not first { d * e === a }

// -----------------------------------------------
// Constructive language (functions)

function factorial (int n) : int {
    if (n == 1) return 1;
    return n * factorial(n-1);
}

function myfunc (expr &selector, expr cols[]) { ... }     // arrays and references

function sum(...) : int {                  // number variable of parameters
    int total = 0;
    for (int index = 0; index < length(args); ++index) {
        if (!(args[index] is int)) error("sum: invalid parameter #$0, it must be an integer", index);
        total += args[index];
    }
    return total;
}

function swap(int a, int b) : [int, int] { ... } // multiple returns
function swap(string a, string b) : [string, string] { .... }    // parametric polymorphism (overloading)
function next3(int a) : [int,int, int] { return [a+1,a+2,a+3]; }

[c,] = swap(a,b);       // ignore one return value
[c,...] = next3(10);    // ignore rest of return values
[n1,,n3] = next3(k);    // ignore one return value


// -----------------------------------------------
// Constructive language (deferred functions)

// called each time that one instance finish
final function on_instance_final_was_called (){
}

// called each time that one subair finish
final subair function on_subair_final_was_called (){
}

// called at end
final air function on_instance_final_was_called (){
}

function myfunc (expr &selector, expr cols[]) {
    // only if function was executed
    // only one time by instance
    on final instance_finished_func(with_args);
    // only one time by subair
    on final subair subair_finished_func(arg1, arg2);
    // only one time is called
    on final air final_func(with_args);
}

// private functions, only visible inside same source file
private function internal_lib_helper() {
}
// -----------------------------------------------
// Constructive language (functions)

col fixed L1 = [1,0...];

when first c === 23;

when first {
  a === 0;
  b === 0;
}

when last {
  gprod === 1,
}

when frame {
    a'3 === a + a' + a'2;
}

when (1-L1) {
    for (integer index = 0; index < 16; ++index) {
        a[index] === b[index] + (1 - c);
    }
}

constant MAX_PUBLIC_TABLE_ROWS = 32;
constant PUBLIC_TABLE_COLS = 10;

function prodColyumns(rowElements) {
    expression expr = 0;
    for (int i=0; i<length(column; i++)) {
        expr = (expr + rowElements[i])*alfa;
    }
    return expr;
}



public table aggregate(prod, prodColumns) gprods[PUBLIC_TABLE_COLS][MAX_PUBLIC_TABLE_ROWS] ;

memory * gprod === 1
binary * gprod0[1] === 1;

// -----------------------------------------------
// Challenges access

col witness a1, a2, b1, b2;

col witness stage(2) h1, h2;
challenge stage(2) epsilon;
challenge stage(3) betas[4];

col f = a1 + epsilon * a2;
col t = b1 + epsilon * b2;

col witness stage(3) z;
challenge stage(3) delta, gamma;

when L1 {z === 1};

z' * ((delta*(1+gamma) + h1 + gamma*h2)) * ((delta*(1+gamma) + h2 + gamma*h1')) ===
   z * (1+gamma)*(delta + f)*(delta*(1+gamma) + t + gamma*t');

// -----------------------------------------------
// Fixed columns generation

// values and repetitions: [value1,value2,value3] [value:times]
// ranges negatives or positives: [from..to] [from:times..to:times]
// repeat up to full:  [value...]
// arithmetic series: [first,second,..+..] [first,second,..+..,last]
// geometric series:  [first,second,..*..] [first,second,..*..,last]

col fixed L1 = [1,0...];            // [1,0:N-1]
col fixed L_LAST = [0...,1];        // [0:N-1,1]

col fixed J = [0:3..127:3,128:2..255:2]...; // 0,0,0,1,1,1,2,2,2,3...127,128,128,129...,254,255,255,0,0,0,1,1,...
col fixed K = [[0,1,2,3]:3, [4,5,6]:2]...;  // 0,1,2,3,0,1,2,3,0,1,2,3,4,5,6,4,5,6,0,1,2,3...
col fixed ODDS = [1,3,..+..];               // 1,3,5,7,9,11,13,15,17,19,21,23,25,...
col fixed FACTOR = [1,2,..*..,2**32]...;    // 1,2,4,8,16,32,64,128,256,512,1024,2048,....,2**31,2**32,1,2,4,...

// using constructive language
col fixed F;
F[0] = 0;
F[1] = 1;
for (int i=2; i<N; ++i) {
   F[i] = F[i-1] + F[i-2];
}


// -----------------------------------------------
// Previous and next rows access

// <n>'<col>        'LATCH, 2'LATCH,
// <col>'<n>        LATCH', LATCH'2,
// (<exp>)'<col>    (i+1)'LATCH
// <col>'(<exp>)    LATCH'(i+1)

4'carry === 0;
carry'4 === 0;

col fixed FACTOR0 = [1,2**8,2**16,2**24,0:28]....;
col FACTOR[8];     // FACTOR[0] = [1,2**8,2**16,2**24,0:28]....
                   // FACTOR[1] = [0:4,1,2**8,2**16,2**24,0:24]....
                   //    :
                   // FACTOR[7] = [0:28,1,2**8,2**16,2**24]....

for (integer i=0; i<7; i++) {
   FACTOR[i] = FACTOR0'(i*4);
}

// -----------------------------------------------
// Previous and next rows access (cont)

col witness abc[8];

expr expr_abc[3];
for (integer i = 0; i < 16; ++i) {
   integer j = i*4;
   when LATCH {   // LATCH = CLK15
         abc[i] ===   (j)'freeInA[0]         + (j-1)'freeInA[1] * 2**8 +       // CLK15
                    (j-2)'freeInA[0] * 2**16 + (j-3)'freeInA[1] * 2**24;

        'abc[i] ===   (j)'freeInB[0]         + (j-1)'freeInB[1] * 2**8 +       // CLK14 == 'LATCH
                    (j-2)'freeInB[0] * 2**16 + (j-3)'freeInB[1] * 2**24;

       2'abc[i] ===   (j)'freeInC[0]         + (j-1)'freeInC[1] * 2**8 +       // CLK13 == 2'LATCH
                    (j-2)'freeInC[0] * 2**16 + (j-3)'freeInC[1] * 2**24;
   }
}


// -----------------------------------------------
// Range checks

col witness sel;
col witness a,b;

range_check(sel, a, 0, 2**16-1);
range_check(b, 0, 255);

col witness c[32];
expr clkC;
for (integer index = 0; index < 32; ++index) {
    clkC = clkC + CLK32[index] * c[i];
    when (1-RESET) c[i]' === c[i];
}
range_check(clkC, 0, 255);

// -----------------------------------------------
// Custom data

function lookup_check (expr selF, expr colsF[], expr selT, expr colsT[]) {
   @lookup {selF:selF, colsF:colsF, selT:selT, colsT: colsT};
}

// to extend to new features
function myfuturefunc (expr v) {
   @myfuturefunc {colsF: v}
}

// front-end data could be more complex as key: value or combinations
function lookup (expr selF, expr colsF[], expr selT, expr colsT[]) {
   @the_name_that_I_want {selF: 1,     // keys aren't resolved
             colsF: colsF,             // values resolved (value, expression or column reference)
             selT: 1,
             colsT: colsT};
}


// -----------------------------------------------
// Buildin functions

// builtin variables
N                                           // key with number of rows
BITS                                        // key with bits of N
PRIME                                       // key with prime of fe
SOURCE                                      // string with source reference (pil)

print("hello");                                 // print values without LF
println(" world my name is", name);             // same as print but with LF
warning("number $0 too big, be careful", i);    // show warning but continue
error("division by zero");                      // show error and doesn't continue
assert(expected == res, "invalid result");      // if conditions was false then show error and doesn't continue

namespace_of(A)                             // return namespace of A (string)
subair_of(A)                                // return subproof of A (string)
stage_of(A)                                 // return stage of A (integer)
length(A)                                   // return length of array (integer) or length of string
dim(A)                                      // return number of dimensions
log2(N)                                     // return log2 of N
is_array(A)                                 // return if A is an array
defined(A)                                  // return if A is declared and defined

A is fe                                     // return if A is an fe (could be used with other types)
A is expr[]                                 // return if A is an array of expressions

`template string ${N}`                      // template string




// custom data  provides extra information to nexts steps (backend)
function lookup_check (expr selF, expr colsF[], expr selT, expr colsT[]) {
    @lookup_check [selF, colsF, selT, colsT];
}

// to extend to new features
function myfuturefunc (expr value) {
    @myfuturefunc value
}

// custom data could be more complex as key: value or combinations
function lookup_check (expr selF, expr colsF[], expr selT, expr colsT[]) {
    @the_name_that_I_want {selF: 1,     // keys aren't resolved
              colsF: colsF,             // values resolved (value, expression or column reference)
              selT: 1,
              colsT: colsT};
}

// -----------------------------------------------
// Lookup

lookup_check (
   hashK + hashK1,
       [ addr,
         op0, op1, op2, op3
       ],
   PaddingKK.crLatch * PaddingKK.r8valid,
       [
         PaddingKK.addr,
         PaddingKK.crV0C, PaddingKK.crV1C, PaddingKK.crV2C, PaddingKK.crV3C
       ]
   );

function lookup_check (expr selF, expr colsF[], expr selT, expr colsT[]) {
   setup_L1();
   @lookup_check { selF: selF, colsF: colsF, selT: colsT }
}

function setup_L1() {
   if (!(L1 is col)) {
       global col fixed L1 = [1,0...];
   }
}

// -----------------------------------------------
// Lookup

lookup_check (
   hashK + hashK1,
       [ addr,
         op0, op1, op2, op3
       ],
   PaddingKK.crLatch * PaddingKK.r8valid,
       [
         PaddingKK.addr,
         PaddingKK.crV0C, PaddingKK.crV1C, PaddingKK.crV2C, PaddingKK.crV3C
       ]
   );

optional col fixed L1;

function lookup_check (expr selF, expr colsF[], expr selT, expr colsT[]) {
   setup_L1();
   @lookup_check { selF: selF, colsF: colsF, selT: colsT }
}

function setup_L1() {
   if (!defined(L1)) L1 = [1,0...];
}

// -----------------------------------------------
// Example: match

s === match(selEq,
    1, x1[0],
    2, x2[0],
    3, y2[0]
);

function match (col sel, ...) : expr {

    @match {selector: sel, cases: args}

    integer argc = length(args);
    if (length(args) % 2 != 0) {
        error(`match was called with number incorrect ${argc}`);
    }
    for (integer icase = 0; icase < argc; icase = icase + 2) {
        if (!(args[icase] is fe)) error(`selector must be a constant value on ${icase}`);
        if (!(args[icase+1] is expr)) error(`expression must be a constant value on ${icase}`);
    }

    expr bc, res;
    integer cases = argc \ 2;
    col L[argc \ 2];
    for (integer icase = 0; icase < argc; icase = icase + 2) {
        expr lexpr;
        fe invl = 1;
        fe csel = args[icase]
        expr cexpr = args[icase + 1];

        for (integer j = 0; j < cases; ++j) {
            if (i == j) continue;
            lexpr = lexpr * (sel * args[2 * j]);
            invl = invl * (csel - args[2 * j]);
        }

        bc = bc * (sel - csel);
        L[icase] = lexpr / invl;
        res = res + L[icase] * cexpr;
    }
    bc === 0;
    return res;
}

lookup_check (
    hashK + hashK1,
        [ addr,
          op0, op1, op2, op3,
        ],
    PaddingKK.crLatch * PaddingKK.r8valid,
        [
          PaddingKK.addr,
          PaddingKK.crV0C, PaddingKK.crV1C, PaddingKK.crV2C, PaddingKK.crV3C,
        ]
    );

optional col fixed L1;

function lookup_check (expr selF, expr colsF[], expr selT, expr colsT[]) {
    col L1 = setup_L1();
    @lookup { selF: selF, colsF: colsF, selT: colsT }
}

// declared, defined
function setup_L1() {
    col fixed L1 = [1,0...];
    return L1;
}

function next() {
    static integer counter = 0;
    return counter++;
}

// multiset example

subair aggregate Main(2**23, 2**25) {

    // here are defined cols and constraints of Main

    // define all rows required from Main
    // KECCAK_ID identifier of this multiset.
    // hashK + hashK1 is the selector
    // addr, op[0], op[1], op[2], op[3] are involved cols
    multiset
    multiset_require(KECCAK_ID, hashK + hashK1, [addr,op0, op1, op2, op3]);
}


subair aggregate Keccak(2**23, 2**25) {

    constant KECCAK_ID=10;

    // here are defined cols and constraints of HashK

    // define all rows provided from HashK
    // crLatch * r8valid is the selector
    // addr, crVC[0], crVC[1], crVC[2], crVC[3] are involved cols
    multiset_provide(KECCAK_ID, crLatch * r8valid, [addr, crVC[0], crVC[1], crVC[2], crVC[3]);
}


connect_require(CONNECT_ID, [addr, op0, op1, op2, op3]);
connect_add(CONNECT_ID, addr, offset + 23, op3, offset + 26);  // crea les columnes fixed, + permuta => final instance connect_final
connect_add(CONNECT_ID, op3, offset + 17, op1, offset + 105);  // permuta
// final => connect_provide(CONNECT_ID, [_addr, _op0,...])

int connect_id = connect_require([addr, op0, op1, op2, op3]);
connect_add(connect_id, addr, offset + 23, op3, offset + 26);  // crea les columnes fixed, + permuta => final instance connect_final
connect_add(connect_id, op3, offset + 17, op1, offset + 105);  // permuta



connect_require(CONNECT_ID, [addr, op0, op1, op2, op3]);
connect_provide(CONNECT_ID, [addr, op[0], op[1], op[2], op[3]]);


function init_coset_constants(int len) {
    global std_ks[len];

    for (int i = 0; i < len; ++i) {
        std_ks[i] = K[i];
    }
}

// constant CONNECT_K =
// constant CONNECT_WI =


// init_ks
// exports.getKs = function getKs(Fr, n) {
//     const ks = [Fr.k];
//     for (let i=1; i<n; i++) {
//         ks[i] = Fr.mul(ks[i-1], ks[0]);
//     }
//     return ks;
// }

constant MAX_CONNECT_COLS = 16;

private function init_connect_ks (int len) {
    if (defined(CONNECT_KS)) return;

    if (len > MAX_CONNECT_COLS) {
        error("too many cols (MAX_CONNECT_COLS)");
    }
    if (!defined(CONNECT_K)) {
        error("to use connect functions constant CONNECT_K and CONNECT_WI must be defined");
    }


    constant CONNECT_KS[MAX_CONNECT_COLS];

    fe ks0 = CONNECT_K;
    CONNECT_KS[0] = ks0;
    for (int i=1; i<MAX_CONNECT_COLS; ++i) {
        CONNECT_KS[i] = CONNECT_KS[i-1] * ks0;
    }
}

// let w = F.one;
// for (let i=0; i<N; i++) {
//     pols.ConnA[i] = w;
//     pols.ConnB[i] = F.mul(w, ks[0]);
//     pols.ConnC[i] = F.mul(w, ks[1]);
//     w = F.mul(w, wi);
// }



object o = new connect([addr, op0, op1, op2, op3]);
o.add(addr, offset + 23, op3, offset + 26);

connect_require(CONNECT_ID, [addr, op0, op1, op2, op3]);
connect_add(CONNECT_ID, addr, offset + 23, op3, offset + 26);  // crea les columnes fixed, + permuta => final instance connect_final
connect_add(CONNECT_ID, op3, offset + 17, op1, offset + 105);  // permuta

class Connect {




}


private function init_connect_constants(int len): col fixed [] {
    col fixed CONNECT_CONSTANTS[len];
    fe w = 1;
    for (int irow = 0; irow < N; ++irow) {
        CONNECT_CONSTANTS[0][irow] = w;
        for (int icol = 1; icol < len; ++icol) {
            CONNECT_CONSTANTS[icol][irow] = w * CONNECT_KS[icol-1];
        }
        w = w * CONNECT_WI;
    }
    return CONNECT_CONSTANTS;
}

function connect_require(int id, expr cols[]) {
    constant len = length(cols);

    scope air CONNECT_SCOPE,id {
        int connect_cols;
        col fixed connect_constants[len];
        // TODO: feature copy-arrays
        // expr connect_cols_expr = cols;
        expr connect_cols_expr[MAX_ID][];
        expr connect_cols_expr[len];

        connect_cols = len;
        init_challenges(1);
        init_connect_ks(len);
        connect_constants = init_connect_constants(len);
        // TODO: feature copy-arrays
        // connect_cols_expr = cols;

        for (int i = 0; i < len; ++i) {
            connect_cols_expr[i] = cols[i];
        }
    }
    // array to verify in compilation-time number of columns

}

//     function connect(p1, i1, p2, i2) {
//        [p1[i1], p2[i2]] = [p2[i2], p1[i1]];
//    }

function search_expr (expr needle, expr haystack[]):integer {
    int index = 0;
    int len = length(haystack);
    while (index < len) {
        if (needle == haystack[index]) {
            return index;
        }
        ++index;
    }
    return -1;
}

function connect_add(int id, expr col_a, int row_a, expr col_b, int row_b) {
    // TODO: verify row_a, row_b [0, N-1]
    scope air CONNECT_SCOPE,id {
        int colid_a = search_expr(col_a, connect_cols_exp);
        int colid_b = search_expr( , connect_cols_exp);
        fe previous_a = connect_cols_expr[colid_a][row_a];
        connect_cols_expr[colid_a][row_a] = connect_cols_expr[colid_b][row_b];
        connect_cols_expr[colid_b][row_b] = previous_a;
    }
    final connect_final(id);
}

private function connect_final(int id) {
    scope CONNECT_SCOPE, id {
        connect_provide(id, connect_cols_exp);
    }
}

/**
 * Given multisets A1,...,An and B1,...,Bn, check whether A1,...,An does not vary
 * after applying the permutation B1,...,Bn to itself.
 * @param cols columns subject to the permutation
 * @param Sperms columns defining the permutation
 * @return Constraints to be satisfied by A and B to ensure the connection check
 */
function connection_check(expr cols[], expr Sperms[]) {
    constant len = length(cols);

    init_challenges(1);
    init_coset_constants(len);

    if (len != length(Sperms)) {
        error(`cols and Sperms must be same dimensions`);
    }

    col fixed L1 = [1,0...];
    col fixed IDEN = [1,omega,..*..,omega**(N-1)];

    col witness gprod stage(3);

    // Define SIDs[i] = k_i·X polynomials
    expr SIDs[len];
    for (int icol = 0; icol < len; ++icol) {
        SIDs[icol] = CONNECT_KS[icol] * IDEN;
    }

    //                      (f_0 + gamma·X + delta) · (f_1 + gamma·k_1·X + delta) · ... · (f_N + gamma·k_n·X + delta)
    //  gprod' === gprod * -------------------------------------------------------------------------------------------
    //                      (f_0 + gamma·S_0 + delta) · (f_1 + gamma·S_1 + delta) · ... · (f_N + gamma·S_n + delta)

    expr numerator = 1;
    expr denominator = 1;
    for (int icol = 0; icol < len; ++icol) {
        numerator = numerator * (cols[icol] + std_gamma*SIDs[icol] + std_delta);
        denominator = denominator * (cols[icol] + std_gamma*Sperms[icol] + std_delta);
    }

    L1 * (gprod - 1) === 0;
    gprod' * denominator === gprod * numerator;
}








subproof_permutation_check (
    hashK + hashK1,
        [ addr,
          op0, op1, op2, op3,
        ],
    spKeccak::PaddingKK.crLatch * spKeccak::PaddingKK.r8valid,
        [
          spKeccak::PaddingKK.addr,
          spKeccak::PaddingKK.crV0C, spKeccak::PaddingKK.crV1C, spKeccak::PaddingKK.crV2C, spKeccak::PaddingKK.crV3C,
        ]
    );

function subproof_permutation_check (expr selF, expr colsF[], subproof::expr selT, subproof::expr colsT[]) {
    setup_L1();
    @permutation_check { selF: selF, colsF: colsF, selT: colsT }
    string tSubproof = subproof_of(selT);
    for (subproof::expr &t in colsT) {
        if (subproof_of(t) != tSubproof) error("merda");
    }
    if (subproof_of(selT) == tSubproof)
}

function permutation_check (expr colsF[], subproof::expr colsT[]) {
    permutation_check(1, colsF, 1, colsT);
}

c = connection_check([a,b,c],[A,B,C]);
c.connect([a, 32*index + 3, b, 32*index +4]);
c.repeat_cycle(32);


col witness a,b,c;
col mutable fixed A,B,C;

connection_setup([A,B,C]);

// cyclic example
integer count = N/32;
for (integer index = 0; index < count; ++index) {
    connection_connect([a, 32*index + 3, b, 32*index +4], [A,B,C]);
    connection_connect([a, 32*index +2, c, 32*index +5, b, 32*index +7], [A,B,C]);
}

// shift example
for (integer index = 0; index < N; ++index) {
    connection_connect([a, index, b, index+1], [A,B,C]);
}

connection_check([a,b,c],[A,B,C]);


/*
   expressions representation

operation = 5 bits = 32 operations
operands = number, stack (relative_offset), reference (expression, col, etc.. or all was an expression)

combinations of operands = 3 * 3 = 9 but number op number no sense, 8 valid combinations = 3 bits

5 bits + 3 bits = 1 byte.
number = 32 bytes.
stack, reference = 3 bytes => 16.7 million of references
TOTAL = 36 bytes (32 bits aligned)

results in parallel stack, array of 32 bytes.

expression of 10240 operations = 360K (expressions) + 320K (results)
*/


// function to verify that number of columns of same multiset (requires, provides)
// was the same.

    scope `myscope` {
        :
    }

    scope `myscope-${id}` {
    }


    // scopes could be persistent when exit of scope, for this reason
    // when scope was used/defined must indicate when it's destroyed

    scope persistent proof `mypersistent-scope-${id}` {
        // this scope was destroyed at final
    }

    scope persistent air `mypersistent-scope-${id}` {
        // this scope was destroyed when air finish
    }

    // global define element on other scope, in this case scope_reference = proof
    global proof expr myproofexpr;

    // global could be defined on namedscope
    global `myscope` expr myproofexpr;
    global `myscope` expr myproofexpr;
    global `myscope` expr myproofexpr;